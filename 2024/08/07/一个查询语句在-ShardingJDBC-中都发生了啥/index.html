<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>一个查询语句在 ShardingJDBC 中都发生了啥 | Jerry Chan</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="">
    <meta name="description" content="随着业务数据的增长，原本公司中的分库分表方案相对来说不够灵活，所以决定引入业内相对较为成熟的分库分表组件。通过接入成本、性能损耗、社区活跃等多方面考虑，决定引入 SharidngJDBC。但是目前 ShardingJDBC 对部分现有业务无法做到太友好的支持，所以决定基于现有扩展点扩展或者改造源码，为此需要深入阅读 ShardingJDBC 源码。  ShardingJDBC 架构图">
<meta property="og:type" content="article">
<meta property="og:title" content="一个查询语句在 ShardingJDBC 中都发生了啥">
<meta property="og:url" content="http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/index.html">
<meta property="og:site_name" content="Jerry Chan">
<meta property="og:description" content="随着业务数据的增长，原本公司中的分库分表方案相对来说不够灵活，所以决定引入业内相对较为成熟的分库分表组件。通过接入成本、性能损耗、社区活跃等多方面考虑，决定引入 SharidngJDBC。但是目前 ShardingJDBC 对部分现有业务无法做到太友好的支持，所以决定基于现有扩展点扩展或者改造源码，为此需要深入阅读 ShardingJDBC 源码。  ShardingJDBC 架构图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s21.ax1x.com/2024/08/07/pkzCD6x.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/08/07/pkzCrX6.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/08/07/pkzCynK.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/08/07/pkzCD6x.png">
<meta property="article:published_time" content="2024-08-07T15:44:48.000Z">
<meta property="article:modified_time" content="2024-08-07T15:58:10.989Z">
<meta property="article:author" content="Jerry Chan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/08/07/pkzCD6x.png">
    
        <link rel="alternate" type="application/atom+xml" title="Jerry Chan" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jerry Chan</h5>
          <a href="mailto:jerrtqtqcjl@gmail.com" title="jerrtqtqcjl@gmail.com" class="mail">jerrtqtqcjl@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                目录
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/JerryQTQcjl" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">一个查询语句在 ShardingJDBC 中都发生了啥</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">一个查询语句在 ShardingJDBC 中都发生了啥</h1>
        <h5 class="subtitle">
            
                <time datetime="2024-08-07T15:44:48.000Z" itemprop="datePublished" class="page-time">
  2024-08-07
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ShardingJDBC-架构图"><span class="post-toc-number">1.</span> <span class="post-toc-text">ShardingJDBC 架构图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解析引擎"><span class="post-toc-number">2.</span> <span class="post-toc-text">解析引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#执行查询"><span class="post-toc-number">3.</span> <span class="post-toc-text">执行查询</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SQL-审计引擎"><span class="post-toc-number">4.</span> <span class="post-toc-text">SQL 审计引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#路由引擎"><span class="post-toc-number">5.</span> <span class="post-toc-text">路由引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#改写引擎"><span class="post-toc-number">6.</span> <span class="post-toc-text">改写引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#合并引擎"><span class="post-toc-number">7.</span> <span class="post-toc-text">合并引擎</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">8.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-一个查询语句在-ShardingJDBC-中都发生了啥"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">一个查询语句在 ShardingJDBC 中都发生了啥</h1>
        <div class="post-meta">
            <time class="post-time" title="2024-08-07 23:44:48" datetime="2024-08-07T15:44:48.000Z"  itemprop="datePublished">2024-08-07</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>随着业务数据的增长，原本公司中的分库分表方案相对来说不够灵活，所以决定引入业内相对较为成熟的分库分表组件。通过接入成本、性能损耗、社区活跃等多方面考虑，决定引入 SharidngJDBC。但是目前 ShardingJDBC 对部分现有业务无法做到太友好的支持，所以决定基于现有扩展点扩展或者改造源码，为此需要深入阅读 ShardingJDBC 源码。</p>
</blockquote>
<h3 id="ShardingJDBC-架构图"><a href="#ShardingJDBC-架构图" class="headerlink" title="ShardingJDBC 架构图"></a>ShardingJDBC 架构图</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s21.ax1x.com/2024/08/07/pkzCD6x.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>以上是从官网拷贝的架构图，图上可以很清晰的看到 SQL 大致流程:</p>
<ol>
<li>解析引擎进行 SQL 解析，根据数据库类型将 SQL 解析成抽象语法树</li>
<li>路由引擎根据路由规则和抽象语法树，生成路由上下文</li>
<li>改写引擎根据路由上下文和抽象语法树，对 SQL 进行改写，并生成改写上下文</li>
<li>根据路由上下文、改写上下文生成执行上下文</li>
<li>执行引擎执行上下文根据库、连接数等进行分组，并发执行 SQL</li>
<li>合并引擎根据路由规则等对执行结果进行合并等。</li>
</ol>
<p>以上是 SQL 大致的执行流程，接下来就从源码层面大致看一下具体执行流程。注：本文是基于 5.5.0 的源码。</p>
<h3 id="解析引擎"><a href="#解析引擎" class="headerlink" title="解析引擎"></a>解析引擎</h3><p>首先看一下 SQL 解析是在哪个阶段执行，再看看具体解析的逻辑。以下是 SQL 解析执行的阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.connection.ShardingSphereConnection#prepareStatement</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShardingSpherePreparedStatement(<span class="keyword">this</span>, sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#ShardingSpherePreparedStatement</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ShardingSpherePreparedStatement</span><span class="params">(<span class="keyword">final</span> ShardingSphereConnection connection, <span class="keyword">final</span> String sql,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> <span class="keyword">int</span> resultSetType, <span class="keyword">final</span> <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">final</span> <span class="keyword">int</span> resultSetHoldability, <span class="keyword">final</span> <span class="keyword">boolean</span> returnGeneratedKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> String[] columns)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">    SQLParserRule sqlParserRule = metaDataContexts.getMetaData().getGlobalRuleMetaData().getSingleRule(SQLParserRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取 sql 解析引擎</span></span><br><span class="line">    SQLParserEngine sqlParserEngine = sqlParserRule.getSQLParserEngine(metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()).getProtocolType());</span><br><span class="line">    <span class="comment">// 可以通过 SQLParserRuleConfiguration 配置缓存</span></span><br><span class="line">    sqlStatement = sqlParserEngine.parse(<span class="keyword">this</span>.sql, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sqlStatementContext = <span class="keyword">new</span> SQLBindEngine(metaDataContexts.getMetaData(), connection.getDatabaseName(), hintValueContext).bind(sqlStatement, Collections.emptyList());</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述可以看到 SQL 解析是在预处理阶段执行的，除了 SQL 解析预处理阶段还初始化了内核处理器，各种执行器等等。</p>
<p>接下来看看 SQL 解析具体是如何执行的，SQL 解析底层依赖于 Antlr4 (不了解的可以看看这边文章 <a href="https://juejin.cn/post/7396247820900352035" target="_blank" rel="noopener">传送门</a> )：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.parser.sql.SQLStatementParserEngine#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果缓存中存在sql对应的 SQLStatement 则直接从缓存中获取，底层使用的 caffeine</span></span><br><span class="line">    <span class="keyword">return</span> useCache ? sqlStatementCache.get(sql) : sqlStatementParserExecutor.parse(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.parser.sql.SQLStatementParserExecutor#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、基于 Antlr4 语法规则生成抽象语法树</span></span><br><span class="line">    <span class="comment">// 2、基于 Antlr4 vistor 生成 SQLStatement</span></span><br><span class="line">    <span class="keyword">return</span> visitorEngine.visit(parserEngine.parse(sql, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.api.SQLParserEngine#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParseASTNode <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通常是优先从缓存中取，如果有则使用缓存，没有则解析</span></span><br><span class="line">    <span class="keyword">return</span> useCache ? parseTreeCache.get(sql) : sqlParserExecutor.parse(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.core.database.parser.SQLParserExecutor#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParseASTNode <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    ParseASTNode result = twoPhaseParse(sql);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ParseASTNode <span class="title">twoPhaseParse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于SPI获取数据库解析器门面，其中包含语法解析器和词法解析器类型</span></span><br><span class="line">    DialectSQLParserFacade sqlParserFacade = DatabaseTypedSPILoader.getService(DialectSQLParserFacade<span class="class">.<span class="keyword">class</span>, <span class="title">databaseType</span>)</span>;</span><br><span class="line">    <span class="comment">// 初始化语法解析器，此处语法解析器是扩展自 Antlr4 生成的代码</span></span><br><span class="line">    SQLParser sqlParser = SQLParserFactory.newInstance(sql, sqlParserFacade.getLexerClass(), sqlParserFacade.getParserClass());</span><br><span class="line">    ((Parser) sqlParser).getInterpreter().setPredictionMode(PredictionMode.SLL);</span><br><span class="line">    <span class="keyword">return</span> (ParseASTNode) sqlParser.parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是 SQL 解析的具体解析逻辑，底层使用 Antlr4，主要是分为两个阶段：</p>
<ol>
<li>使用 Antlr4 生成的语法解析器解析 SQL，生成抽象语法树</li>
<li>使用自定义的 Vistor 遍历抽象语法树，并生成对应的 SQLStatement</li>
</ol>
<p>下面再简单看看 ShardingJDBC 是如何使用 Antlr4 的，具体代码在 shardingsphere-parser 这个模块。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s21.ax1x.com/2024/08/07/pkzCrX6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>以 MySQL Insert 语句的语法规则为例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grammar</span> <span class="string">DMLStatement;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">import</span> <span class="string">BaseRule;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">insert</span></span><br><span class="line">    : INSERT insertSpecification INTO? tableName partitionNames? (insertValuesClause | setAssignmentsClause | insertSelectClause) onDuplicateKeyClause?</span><br><span class="line">    <span class="attr">;</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">insertSpecification</span></span><br><span class="line">    : (LOW_PRIORITY | DELAYED | HIGH_PRIORITY)? IGNORE?</span><br><span class="line">    <span class="attr">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">insertValuesClause</span></span><br><span class="line">    : (LP_ fields? RP_ )? (VALUES | VALUE) (assignmentValues (COMMA_ assignmentValues)* | rowConstructorList) valueReference?</span><br><span class="line">    <span class="attr">;</span></span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s21.ax1x.com/2024/08/07/pkzCynK.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ASTNode <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// execute 是根据 Antlr4 生成的语法规则，tokenStream 是词法解析器解析出来的 Token 流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParseASTNode(execute(), (CommonTokenStream) getTokenStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是抽象语法树解析相关的内容，可以看到主要就是使用 Antlr4 的语法规则文件生成语法解析相关的代码:</p>
<ul>
<li>execute 是 MySQL 语法解析的总入口，定义在 MySQLStatement.g4 中。</li>
<li>getTokenStream 是获取词法解析器解析出的 TokenStream。</li>
<li>parse 方法实际上做的就是将 Antlr4 解析出的抽象语法树和 TokenStream 封装起来，用于后续 Visitor 遍历使用。</li>
</ul>
<p>接下来再看看 SQLStatement 生成的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.api.SQLStatementVisitorEngine#visit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">visit</span><span class="params">(<span class="keyword">final</span> ParseASTNode parseASTNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 visitor, visitor 继承自 Antlr 生成代码</span></span><br><span class="line">    SQLStatementVisitor visitor = SQLStatementVisitorFactory.newInstance(databaseType, SQLVisitorRule.valueOf(parseASTNode.getRootNode().getClass()));</span><br><span class="line">    <span class="comment">// 遍历语法树，生成 SQLStatement</span></span><br><span class="line">    ASTNode result = parseASTNode.getRootNode().accept(visitor);</span><br><span class="line">    appendSQLComments(parseASTNode, result);</span><br><span class="line">    <span class="keyword">return</span> (SQLStatement) result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.mysql.visitor.statement.MySQLStatementVisitor#visitInsert</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ASTNode <span class="title">visitInsert</span><span class="params">(<span class="keyword">final</span> InsertContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO :FIXME, since there is no segment for insertValuesClause, InsertStatement is created by sub rule.</span></span><br><span class="line">    MySQLInsertStatement result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.insertValuesClause()) &#123;</span><br><span class="line">        <span class="comment">// 根据 insert value 语法生成 Statemen</span></span><br><span class="line">        result = (MySQLInsertStatement) visit(ctx.insertValuesClause());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.insertSelectClause()) &#123;</span><br><span class="line">        <span class="comment">// 根据 insert select 语法生成 Statemen</span></span><br><span class="line">        result = (MySQLInsertStatement) visit(ctx.insertSelectClause());</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// assignment </span></span><br><span class="line">        result = <span class="keyword">new</span> MySQLInsertStatement();</span><br><span class="line">        result.setSetAssignment((SetAssignmentSegment) visit(ctx.setAssignmentsClause()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 on duplicate</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.onDuplicateKeyClause()) &#123;</span><br><span class="line">        result.setOnDuplicateKeyColumns((OnDuplicateKeyColumnsSegment) visit(ctx.onDuplicateKeyClause()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置表名</span></span><br><span class="line">    result.setTable((SimpleTableSegment) visit(ctx.tableName()));</span><br><span class="line">    <span class="comment">// 这个暂时不知道作用</span></span><br><span class="line">    result.addParameterMarkerSegments(getParameterMarkerSegments());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Visitor 的作用主要就是自定义遍历抽象语法树的逻辑，Antlr4 定义的每个语法规则都会生成一个 visit 方法，为了方便理解，可以简单的认为每个节点都会生成一个 visit 方法，visit 方法的入参是抽象语法树的根节点，传入的如果是非叶子节点（子节点）则遍历的是子树。</p>
<p>接下来简单分析一下 visitInsert 方法：</p>
<ul>
<li>visitInsert 是 Insert 语法子树的入口，当执行 parseASTNode.getRootNode().accept(visitor) 会从 visitExecute 开始执行，最终执行到 visitInsert。</li>
<li>如果 insertValuesClause 子树不为空，则遍历 insertValuesClause 子树。</li>
<li>如果 insertSelectClause 子树不为空，则遍历 insertSelectClause 子树。</li>
<li>其他步骤大多类似，最终将遍历各个子树的结果 (Statement) 组装成  Statement 返回。</li>
</ul>
<h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>接下来看一下执行查询相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建查询上下文</span></span><br><span class="line">        QueryContext queryContext = createQueryContext();</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        handleAutoCommit(queryContext);</span><br><span class="line">        <span class="comment">// 流量治理相关？暂时不知道作用</span></span><br><span class="line">        trafficInstanceId = getInstanceIdAndSet(queryContext).orElse(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trafficInstanceId) &#123;</span><br><span class="line">            JDBCExecutionUnit executionUnit = createTrafficExecutionUnit(trafficInstanceId, queryContext);</span><br><span class="line">            <span class="keyword">return</span> executor.getTrafficExecutor().execute(executionUnit, (statement, sql) -&gt; ((PreparedStatement) statement).executeQuery());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// todo 联邦查询相关</span></span><br><span class="line">        useFederation = decide(queryContext,</span><br><span class="line">                metaDataContexts.getMetaData().getDatabase(databaseName), metaDataContexts.getMetaData().getGlobalRuleMetaData());</span><br><span class="line">        <span class="keyword">if</span> (useFederation) &#123;</span><br><span class="line">            <span class="keyword">return</span> executeFederationQuery(queryContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建执行上下文</span></span><br><span class="line">        executionContext = createExecutionContext(queryContext);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        result = doExecuteQuery(executionContext);</span><br><span class="line">        <span class="comment">// CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RuntimeException ex) &#123;</span><br><span class="line">        <span class="comment">// CHECKSTYLE:ON</span></span><br><span class="line">        handleExceptionInTransaction(connection, metaDataContexts);</span><br><span class="line">        <span class="keyword">throw</span> SQLExceptionTransformEngine.toSQLException(ex, metaDataContexts.getMetaData().getDatabase(databaseName).getProtocolType());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#createExecutionContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExecutionContext <span class="title">createExecutionContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext)</span> </span>&#123;</span><br><span class="line">    RuleMetaData globalRuleMetaData = metaDataContexts.getMetaData().getGlobalRuleMetaData();</span><br><span class="line">    ShardingSphereDatabase currentDatabase = metaDataContexts.getMetaData().getDatabase(databaseName);</span><br><span class="line">    <span class="comment">// sql 审计检查</span></span><br><span class="line">    SQLAuditEngine.audit(queryContext.getSqlStatementContext(), queryContext.getParameters(), globalRuleMetaData, currentDatabase, <span class="keyword">null</span>, queryContext.getHintValueContext());</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 生成执行上下文</span></span><br><span class="line">    ExecutionContext result = kernelProcessor.generateExecutionContext(</span><br><span class="line">            queryContext, currentDatabase, globalRuleMetaData, metaDataContexts.getMetaData().getProps(), connection.getDatabaseConnectionManager().getConnectionContext());</span><br><span class="line">    findGeneratedKey(result).ifPresent(optional -&gt; generatedValues.addAll(optional.getGeneratedValues()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#doExecuteQuery</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ShardingSphereResultSet <span class="title">doExecuteQuery</span><span class="params">(<span class="keyword">final</span> ExecutionContext executionContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    List&lt;QueryResult&gt; queryResults = executeQuery0(executionContext);</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 合并结果、加密、脱敏</span></span><br><span class="line">    MergedResult mergedResult = mergeQuery(queryResults, executionContext.getSqlStatementContext());</span><br><span class="line">    List&lt;ResultSet&gt; resultSets = getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == columnLabelAndIndexMap) &#123;</span><br><span class="line">        columnLabelAndIndexMap = ShardingSphereResultSetUtils.createColumnLabelAndIndexMap(sqlStatementContext, selectContainsEnhancedTable, resultSets.get(<span class="number">0</span>).getMetaData());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShardingSphereResultSet(resultSets, mergedResult, <span class="keyword">this</span>, selectContainsEnhancedTable, executionContext, columnLabelAndIndexMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.connection.kernel.KernelProcessor#generateExecutionContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExecutionContext <span class="title">generateExecutionContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> RuleMetaData globalRuleMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路由，包括分片、读写分离、数据源匹配等等</span></span><br><span class="line">    <span class="comment">// 根据查询上下文、数据库对象、全局规则元数据等参数进行路由，得到路由上下文</span></span><br><span class="line">    RouteContext routeContext = route(queryContext, database, globalRuleMetaData, props, connectionContext);</span><br><span class="line">    <span class="comment">// 根据路由结果改写sql</span></span><br><span class="line">    <span class="comment">// 根据路由上下文和其他参数，对查询语句进行改写，得到改写结果</span></span><br><span class="line">    SQLRewriteResult rewriteResult = rewrite(queryContext, database, globalRuleMetaData, props, routeContext, connectionContext);</span><br><span class="line">    <span class="comment">// 根据查询上下文、数据库对象、路由上下文、改写结果等信息创建执行上下文</span></span><br><span class="line">    ExecutionContext result = createExecutionContext(queryContext, database, routeContext, rewriteResult);</span><br><span class="line">    logSQL(queryContext, props, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行查询主要的逻辑包括执行上下文的创建，以及具体执行查询逻辑。其中联邦查询逻辑由于是实验特性，之后再详看。</p>
<ul>
<li>执行上下文创建主要包括 SQL 审计、分片路由（分库分表、读写分离、影子库）、SQL 改写（分库分表改写、数据加密）</li>
<li>具体执行逻辑主要包括执行上下文分组、根据分组并发执行、查询结果合并（分片结果合并、分页结果合并、数据脱敏、数据加密）</li>
</ul>
<h3 id="SQL-审计引擎"><a href="#SQL-审计引擎" class="headerlink" title="SQL 审计引擎"></a>SQL 审计引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLAuditEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(<span class="keyword">final</span> SQLStatementContext sqlStatementContext, <span class="keyword">final</span> List&lt;Object&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> Grantee grantee, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">        Collection&lt;ShardingSphereRule&gt; rules = <span class="keyword">new</span> LinkedList&lt;&gt;(globalRuleMetaData.getRules());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != database) &#123;</span><br><span class="line">            rules.addAll(database.getRuleMetaData().getRules());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据分片规则获取对应的审计规则</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLAuditor&gt; entry : OrderedSPILoader.getServices(SQLAuditor<span class="class">.<span class="keyword">class</span>, <span class="title">rules</span>).<span class="title">entrySet</span>()) </span>&#123;</span><br><span class="line">            entry.getValue().audit(sqlStatementContext, params, grantee, globalRuleMetaData, database, entry.getKey(), hintValueContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>审计规则比较简单，主要就是基于 SPI 获取规则对应的审计规则，例如默认的分片审计规则不允许 SQL 中没有分片条件。</p>
<h3 id="路由引擎"><a href="#路由引擎" class="headerlink" title="路由引擎"></a>路由引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.route.engine.impl.PartialSQLRouteExecutor#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">route</span><span class="params">(<span class="keyword">final</span> ConnectionContext connectionContext, <span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database)</span> </span>&#123;</span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    <span class="comment">// 强制路由库</span></span><br><span class="line">    Optional&lt;String&gt; dataSourceName = findDataSourceByHint(queryContext.getHintValueContext(), database.getResourceMetaData().getStorageUnits());</span><br><span class="line">    <span class="keyword">if</span> (dataSourceName.isPresent()) &#123;</span><br><span class="line">        result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(dataSourceName.get(), dataSourceName.get()), Collections.emptyList()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 装饰器装饰路由上下文，这里的 routers 根据配置的规则而确定，例如 shardingRule，readWriteSplitRule 都会有对应的 routers</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLRouter&gt; entry : routers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.getRouteUnits().isEmpty()) &#123;</span><br><span class="line">            result = entry.getValue().createRouteContext(queryContext, globalRuleMetaData, database, entry.getKey(), props, connectionContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.getValue().decorateRouteContext(result, queryContext, database, entry.getKey(), props, connectionContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.getRouteUnits().isEmpty() &amp;&amp; <span class="number">1</span> == database.getResourceMetaData().getStorageUnits().size()) &#123;</span><br><span class="line">        String singleDataSourceName = database.getResourceMetaData().getStorageUnits().keySet().iterator().next();</span><br><span class="line">        result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(singleDataSourceName, singleDataSourceName), Collections.emptyList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析下上面的代码：</p>
<ul>
<li>如果是强制路由数据库，则直接返回。</li>
<li>根据规则获取 SQLRouter，SQLRouter 由 SPI 加载，其中包括单表、分库分表、广播、读写分离影子库等多种 SQLRouter。</li>
<li>SQLRouter 采用装饰器模式，SQLRouter 中定义了优先级，优先级最高的 SQLRouter 创建路由上下文，之后的 SQLRouter 负责装饰路由上下文。</li>
</ul>
<p>接下来看一下分库分表和读写分离，其他的感兴趣的可以自行看看源码，首先看一下分库分表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.ShardingSQLRouter#createRouteContext0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RouteContext <span class="title">createRouteContext0</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> ShardingRule rule,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询上下文中的 sql 语句</span></span><br><span class="line">    SQLStatement sqlStatement = queryContext.getSqlStatementContext().getSqlStatement();</span><br><span class="line">    <span class="comment">// 解析分片条件</span></span><br><span class="line">    ShardingConditions shardingConditions = createShardingConditions(queryContext, globalRuleMetaData, database, rule);</span><br><span class="line">    <span class="comment">// todo 校验 sql 语句</span></span><br><span class="line">    Optional&lt;ShardingStatementValidator&gt; validator = ShardingStatementValidatorFactory.newInstance(sqlStatement, shardingConditions, globalRuleMetaData);</span><br><span class="line">    validator.ifPresent(optional -&gt; optional.preValidate(rule, queryContext.getSqlStatementContext(), queryContext.getParameters(), database, props));</span><br><span class="line">    <span class="comment">// 包含子查询需要合并分片条件</span></span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> DMLStatement &amp;&amp; shardingConditions.isNeedMerge()) &#123;</span><br><span class="line">        <span class="comment">// 合并查询条件</span></span><br><span class="line">        shardingConditions.merge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据sql语句类型，路由规则等获取分片引擎，并分片</span></span><br><span class="line">    RouteContext result = ShardingRouteEngineFactory.newInstance(rule, database, queryContext, shardingConditions, props, connectionContext, globalRuleMetaData)</span><br><span class="line">            .route(rule);</span><br><span class="line">    <span class="comment">// todo 后置校验</span></span><br><span class="line">    validator.ifPresent(optional -&gt; optional.postValidate(rule, queryContext.getSqlStatementContext(), queryContext.getHintValueContext(), queryContext.getParameters(), database, props, result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 ShardingSQLRouter 创建路由上下文的逻辑，主要包括：</p>
<ul>
<li>根据分片规则解析分表条件，包括分片表、分片字段、字段值。</li>
<li>SQL 语句校验。</li>
<li>根据分片规则创建对应的分片路由引擎，并创建路由上下文。</li>
</ul>
<p>下面看看最简单的分片规则路由引擎 (ShardingStandardRoutingEngine) 是怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">route</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule)</span> </span>&#123;</span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 根据规则，获取数据节点</span></span><br><span class="line">    Collection&lt;DataNode&gt; dataNodes = getDataNodes(shardingRule, shardingRule.getShardingTable(logicTableName));</span><br><span class="line">    result.getOriginalDataNodes().addAll(originalDataNodes);</span><br><span class="line">    <span class="keyword">for</span> (DataNode each : dataNodes) &#123;</span><br><span class="line">        <span class="comment">// 以路由单位进行封装，封装逻辑库与实际库映射，逻辑表与实际表映射</span></span><br><span class="line">        result.getRouteUnits().add(</span><br><span class="line">                <span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(each.getDataSourceName(), each.getDataSourceName()), Collections.singleton(<span class="keyword">new</span> RouteMapper(logicTableName, each.getTableName()))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#getDataNodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDataNodes</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ShardingTable shardingTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据规则获取数据库分片策略</span></span><br><span class="line">    ShardingStrategy databaseShardingStrategy = createShardingStrategy(shardingRule.getDatabaseShardingStrategyConfiguration(shardingTable),</span><br><span class="line">            shardingRule.getShardingAlgorithms(), shardingRule.getDefaultShardingColumn());</span><br><span class="line">    <span class="comment">// 根据规则获取表分片策略</span></span><br><span class="line">    ShardingStrategy tableShardingStrategy = createShardingStrategy(shardingRule.getTableShardingStrategyConfiguration(shardingTable),</span><br><span class="line">            shardingRule.getShardingAlgorithms(), shardingRule.getDefaultShardingColumn());</span><br><span class="line">    <span class="comment">// 强制路由</span></span><br><span class="line">    <span class="keyword">if</span> (isRoutingByHint(shardingRule, shardingTable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> routeByHint(shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件路由</span></span><br><span class="line">    <span class="keyword">if</span> (isRoutingByShardingConditions(shardingRule, shardingTable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> routeByShardingConditions(shardingRule, shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 混合强制路由和条件路由，库和表分片其中一个是强制路由</span></span><br><span class="line">    <span class="keyword">return</span> routeByMixedConditions(shardingRule, shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#routeByShardingConditionsWithCondition</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByShardingConditionsWithCondition</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ShardingTable shardingTable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                        <span class="keyword">final</span> ShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> ShardingStrategy tableShardingStrategy)</span> </span>&#123;</span><br><span class="line">    Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据分片条件路由，获取数据节点</span></span><br><span class="line">    <span class="keyword">for</span> (ShardingCondition each : shardingConditions.getConditions()) &#123;</span><br><span class="line">        Collection&lt;DataNode&gt; dataNodes = route0(shardingTable,</span><br><span class="line">                databaseShardingStrategy, getShardingValuesFromShardingConditions(shardingRule, databaseShardingStrategy.getShardingColumns(), each),</span><br><span class="line">                tableShardingStrategy, getShardingValuesFromShardingConditions(shardingRule, tableShardingStrategy.getShardingColumns(), each));</span><br><span class="line">        result.addAll(dataNodes);</span><br><span class="line">        originalDataNodes.add(dataNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#route0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">route0</span><span class="params">(<span class="keyword">final</span> ShardingTable shardingTable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> ShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> List&lt;ShardingConditionValue&gt; databaseShardingValues,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> ShardingStrategy tableShardingStrategy, <span class="keyword">final</span> List&lt;ShardingConditionValue&gt; tableShardingValues)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路由到对应数据库</span></span><br><span class="line">    Collection&lt;String&gt; routedDataSources = routeDataSources(shardingTable, databaseShardingStrategy, databaseShardingValues);</span><br><span class="line">    Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 路由到对应表</span></span><br><span class="line">    <span class="keyword">for</span> (String each : routedDataSources) &#123;</span><br><span class="line">        result.addAll(routeTables(shardingTable, each, tableShardingStrategy, tableShardingValues));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.strategy.type.standard.StandardShardingStrategy#doSharding</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingConditionValue&gt; shardingConditionValues,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">final</span> DataNodeInfo dataNodeInfo, <span class="keyword">final</span> ConfigurationProperties props)</span> </span>&#123;</span><br><span class="line">    ShardingConditionValue shardingConditionValue = shardingConditionValues.iterator().next();</span><br><span class="line">    <span class="comment">// 根据分片列是精确查询还是范围查询调用对应的处理方法</span></span><br><span class="line">    Collection&lt;String&gt; shardingResult = shardingConditionValue <span class="keyword">instanceof</span> ListShardingConditionValue</span><br><span class="line">            ? doSharding(availableTargetNames, (ListShardingConditionValue) shardingConditionValue, dataNodeInfo)</span><br><span class="line">            : doSharding(availableTargetNames, (RangeShardingConditionValue) shardingConditionValue, dataNodeInfo);</span><br><span class="line">    Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">    result.addAll(shardingResult);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.strategy.type.standard.StandardShardingStrategy#doSharding</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ListShardingConditionValue&lt;?&gt; shardingValue, <span class="keyword">final</span> DataNodeInfo dataNodeInfo)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Object each : shardingValue.getValues()) &#123;</span><br><span class="line">        <span class="comment">// 这里就是我们指定的或者自定义的分片算法</span></span><br><span class="line">        String target = shardingAlgorithm.doSharding(availableTargetNames,</span><br><span class="line">                <span class="keyword">new</span> PreciseShardingValue(shardingValue.getTableName(), shardingValue.getColumnName(), dataNodeInfo, each));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != target &amp;&amp; availableTargetNames.contains(target)) &#123;</span><br><span class="line">            result.add(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != target &amp;&amp; !availableTargetNames.contains(target)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ShardingRouteAlgorithmException(target, availableTargetNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来简单分析一下，上述代码是以分片条件进行路由：</p>
<ul>
<li>路由上下文主要是由一组路由单元组成，路由单元中主要包括库映射和表映射。</li>
<li>路由主要包括库路由和表路由，其中包括强制路由、分片路由、混合强制路由（库强制标条件或者库条件表强制）。</li>
<li>路由的可用数据节点 (DataNodes) 是根据表分片规则的 AcutalDataNode 解析的。</li>
<li>根据我们分片规则指定的分片算法进行路由，路由主要包括等值条件路由和范围条件路由。</li>
<li>如果 SQL 没有分片条件，则进行全库表路由。</li>
</ul>
<p>接下来看看读写分离的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingSQLRouter#createRouteContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">createRouteContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> ReadwriteSplittingRule rule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ReadwriteSplittingSQLRouter在所有SQLRouter中排最后一位，如果是创建路由上下文则说明当前SQL未匹配其他路由条件</span></span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    ReadwriteSplittingDataSourceRule singleDataSourceRule = rule.getSingleDataSourceRule();</span><br><span class="line">    <span class="comment">// 直接使用ReadwriteSplittingDataSourceRouter来进行路由</span></span><br><span class="line">    String dataSourceName = <span class="keyword">new</span> ReadwriteSplittingDataSourceRouter(singleDataSourceRule, connectionContext).route(queryContext.getSqlStatementContext(), queryContext.getHintValueContext());</span><br><span class="line">    result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(singleDataSourceRule.getName(), dataSourceName), Collections.emptyList()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingSQLRouter#decorateRouteContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorateRouteContext</span><span class="params">(<span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> ShardingSphereDatabase database,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> ReadwriteSplittingRule rule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    Collection&lt;RouteUnit&gt; toBeRemoved = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collection&lt;RouteUnit&gt; toBeAdded = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeContext.getRouteUnits()) &#123;</span><br><span class="line">        <span class="comment">// 获取逻辑库对应的读写分离规则，如果逻辑库存在对应规则，并且路由单元的实际库等于读写分离规则名</span></span><br><span class="line">        String dataSourceName = each.getDataSourceMapper().getLogicName();</span><br><span class="line">        Optional&lt;ReadwriteSplittingDataSourceRule&gt; dataSourceRule = rule.findDataSourceRule(dataSourceName);</span><br><span class="line">        <span class="keyword">if</span> (dataSourceRule.isPresent() &amp;&amp; dataSourceRule.get().getName().equalsIgnoreCase(each.getDataSourceMapper().getActualName())) &#123;</span><br><span class="line">            toBeRemoved.add(each);</span><br><span class="line">            <span class="comment">// 重新构建路由单元</span></span><br><span class="line">            String actualDataSourceName = <span class="keyword">new</span> ReadwriteSplittingDataSourceRouter(dataSourceRule.get(), connectionContext).route(queryContext.getSqlStatementContext(),</span><br><span class="line">                    queryContext.getHintValueContext());</span><br><span class="line">            toBeAdded.add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(each.getDataSourceMapper().getLogicName(), actualDataSourceName), each.getTableMappers()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    routeContext.getRouteUnits().removeAll(toBeRemoved);</span><br><span class="line">    routeContext.getRouteUnits().addAll(toBeAdded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingDataSourceRouter#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">route</span><span class="params">(<span class="keyword">final</span> SQLStatementContext sqlStatementContext, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (QualifiedReadwriteSplittingDataSourceRouter each : getQualifiedRouters(connectionContext)) &#123;</span><br><span class="line">        <span class="comment">// 1、写操作、上锁、强制写 2、事务</span></span><br><span class="line">        <span class="keyword">if</span> (each.isQualified(sqlStatementContext, rule, hintValueContext)) &#123;</span><br><span class="line">            <span class="keyword">return</span> each.route(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负载均衡到从库（过滤禁用从库）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardReadwriteSplittingDataSourceRouter().route(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingDataSourceRouter#getQualifiedRouters</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;QualifiedReadwriteSplittingDataSourceRouter&gt; <span class="title">getQualifiedRouters</span><span class="params">(<span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、QualifiedReadwriteSplittingPrimaryDataSourceRouter 写操作、上锁、强制路由路由主库</span></span><br><span class="line">    <span class="comment">// 2、QualifiedReadwriteSplittingTransactionalDataSourceRouter 事务默认路由主库，FIXED、DYNAMIC策略读从库(过滤禁用的从库)</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> QualifiedReadwriteSplittingPrimaryDataSourceRouter(), <span class="keyword">new</span> QualifiedReadwriteSplittingTransactionalDataSourceRouter(connectionContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读写分离路由器主要分为创建路由单元和装饰路由单元</li>
<li>由于读写分离路由器在所有路由器中排在最后一位，如果是创建路由单元说明其他路由规则都没有匹配到，此时直接使用 ReadwriteSplittingDataSourceRouter 进行路由</li>
<li>如果是装饰路由上下文，则遍历路由单元，如果匹配上读写分离规则则重新使用 ReadwriteSplittingDataSourceRouter 进行路由后覆盖原本的路由单元</li>
<li>ReadwriteSplittingDataSourceRouter 主要是根据以下两个条件判断是否读主库<ul>
<li>写操作、上锁、强制路由路由主库</li>
<li>事务默认路由主库，FIXED、DYNAMIC策略读从库(过滤禁用的从库)</li>
<li>其他情况都是负载均衡到从库（具体负载均衡规则是我们自己指定的）</li>
</ul>
</li>
</ul>
<h3 id="改写引擎"><a href="#改写引擎" class="headerlink" title="改写引擎"></a>改写引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#rewrite</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLRewriteResult <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 创建sql改写上下文，包括sqlToken的生成</span></span><br><span class="line">    SQLRewriteContext sqlRewriteContext = createSQLRewriteContext(queryContext, routeContext, connectionContext);</span><br><span class="line">    SQLTranslatorRule rule = globalRuleMetaData.getSingleRule(SQLTranslatorRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 改写，根据是否有路由单元选择对应的改写引擎</span></span><br><span class="line">    <span class="keyword">return</span> routeContext.getRouteUnits().isEmpty()</span><br><span class="line">            ? <span class="keyword">new</span> GenericSQLRewriteEngine(rule, database, globalRuleMetaData).rewrite(sqlRewriteContext, queryContext)</span><br><span class="line">            : <span class="keyword">new</span> RouteSQLRewriteEngine(rule, database, globalRuleMetaData).rewrite(sqlRewriteContext, routeContext, queryContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL 改写主要有两个部分组成：</p>
<ol>
<li>SQL 改写上下文的创建，包括 sqlToken 的生成，sqlToken 主要用于改写 SQL。</li>
<li>根据路由上下文和 SQL 改写上下文进行改写。</li>
</ol>
<p>接下来先看一下 SQL 改写上下文的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#createSQLRewriteContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLRewriteContext <span class="title">createSQLRewriteContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    HintValueContext hintValueContext = queryContext.getHintValueContext();</span><br><span class="line">    SQLRewriteContext result = <span class="keyword">new</span> SQLRewriteContext(database, queryContext.getSqlStatementContext(), queryContext.getSql(), queryContext.getParameters(), connectionContext, hintValueContext);</span><br><span class="line">    <span class="comment">// 装饰sql改写上下文</span></span><br><span class="line">    decorate(decorators, result, routeContext, hintValueContext);</span><br><span class="line">    <span class="comment">// 生成 sqlToken，sqlToken 主要是针对sql语句的各个分段进行改写，例如表名、字段、字段值等等</span></span><br><span class="line">    result.generateSQLTokens();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> Map&lt;ShardingSphereRule, SQLRewriteContextDecorator&gt; decorators, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 强制路由可以绕过改写</span></span><br><span class="line">    <span class="keyword">if</span> (hintValueContext.isSkipSQLRewrite()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLRewriteContextDecorator&gt; entry : decorators.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// ☆☆☆☆核心☆☆☆☆ 基于装饰器扩展点，可以添加一些自己需要的sqlToken，用于扩展改写sql</span></span><br><span class="line">        entry.getValue().decorate(entry.getKey(), props, sqlRewriteContext, routeContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.context.ShardingSQLRewriteContextDecorator#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext)</span> </span>&#123;</span><br><span class="line">    SQLStatementContext sqlStatementContext = sqlRewriteContext.getSqlStatementContext();</span><br><span class="line">    <span class="keyword">if</span> (sqlStatementContext <span class="keyword">instanceof</span> InsertStatementContext &amp;&amp; !containsShardingTable(shardingRule, sqlStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sqlRewriteContext.getParameters().isEmpty()) &#123;</span><br><span class="line">        Collection&lt;ParameterRewriter&gt; parameterRewriters =</span><br><span class="line">                <span class="keyword">new</span> ShardingParameterRewriterBuilder(shardingRule, routeContext, sqlRewriteContext.getDatabase().getSchemas(), sqlStatementContext).getParameterRewriters();</span><br><span class="line">        rewriteParameters(sqlRewriteContext, parameterRewriters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加sqlToken构建器</span></span><br><span class="line">    sqlRewriteContext.addSQLTokenGenerators(<span class="keyword">new</span> ShardingTokenGenerateBuilder(shardingRule, routeContext, sqlStatementContext).getSQLTokenGenerators());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.token.ShardingTokenGenerateBuilder#getSQLTokenGenerators</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;SQLTokenGenerator&gt; <span class="title">getSQLTokenGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;SQLTokenGenerator&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> TableTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> DistinctProjectionPrefixTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ProjectionsTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> OrderByTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> AggregationDistinctTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> IndexTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ConstraintTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> OffsetTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> RowCountTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyInsertColumnTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyForUseDefaultInsertColumnsTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyAssignmentTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ShardingInsertValuesTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyInsertValuesTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ShardingRemoveTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> CursorTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> FetchDirectionTokenGenerator());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.token.generator.impl.TableTokenGenerator#generateSQLTokens</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;SQLToken&gt; <span class="title">generateSQLTokens</span><span class="params">(<span class="keyword">final</span> TableAvailable sqlStatementContext)</span> </span>&#123;</span><br><span class="line">    Collection&lt;SQLToken&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SimpleTableSegment each : sqlStatementContext.getAllTables()) &#123;</span><br><span class="line">        TableNameSegment tableName = each.getTableName();</span><br><span class="line">        <span class="keyword">if</span> (shardingRule.findShardingTable(tableName.getIdentifier().getValue()).isPresent()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> TableToken(tableName.getStartIndex(), tableName.getStopIndex(), tableName.getIdentifier(), (SQLStatementContext) sqlStatementContext, shardingRule));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SQL 改写上下文的创建最主要就是创建 sqlToken，其中可以分为几个步骤：</p>
<ol>
<li><p>根据规则获取 SQL 改写上下文装饰器，主要包括分片规则和数据加密装饰器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decorators = OrderedSPILoader.getServices(SQLRewriteContextDecorator<span class="class">.<span class="keyword">class</span>, <span class="title">database</span>.<span class="title">getRuleMetaData</span>().<span class="title">getRules</span>())</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>装饰器主要作用就是添加 sqlToken 构建器。</p>
</li>
<li><p>统一生成 sqlToken，sqlToken 主要是针对 SQL 语句的各个分段进行改写，例如表名、字段、字段值等等。以 TableToken 为例，TableToken 从 SQL 解析出来的 TableStatement 中获取到表名的起始结束位置，改写时就是利用字符串截取替换起始结束位置之间的字符串。</p>
</li>
</ol>
<p>接下来看一下具体的改写逻辑实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#rewrite</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RouteSQLRewriteResult <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> QueryContext queryContext)</span> </span>&#123;</span><br><span class="line">    Map&lt;RouteUnit, SQLRewriteUnit&gt; sqlRewriteUnits = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(routeContext.getRouteUnits().size(), <span class="number">1F</span>);</span><br><span class="line">    <span class="comment">// 根据数据库分组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Collection&lt;RouteUnit&gt;&gt; entry : aggregateRouteUnitGroups(routeContext.getRouteUnits()).entrySet()) &#123;</span><br><span class="line">        Collection&lt;RouteUnit&gt; routeUnits = entry.getValue();</span><br><span class="line">        <span class="comment">// 同一个库的查询语句，且不包含子查询、关联查询、排序、分页、锁</span></span><br><span class="line">        <span class="keyword">if</span> (isNeedAggregateRewrite(sqlRewriteContext.getSqlStatementContext(), routeUnits)) &#123;</span><br><span class="line">            <span class="comment">// 用 union all 连接 sql</span></span><br><span class="line">            sqlRewriteUnits.put(routeUnits.iterator().next(), createSQLRewriteUnit(sqlRewriteContext, routeContext, routeUnits));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 改写sql后封装成sql改写单元</span></span><br><span class="line">            addSQLRewriteUnits(sqlRewriteUnits, sqlRewriteContext, routeContext, routeUnits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻译SQL，官方暂未提供实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RouteSQLRewriteResult(translate(queryContext, sqlRewriteUnits));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#createSQLRewriteUnit</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLRewriteUnit <span class="title">createSQLRewriteUnit</span><span class="params">(<span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; sql = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Object&gt; params = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 参数是否是$开头</span></span><br><span class="line">    <span class="keyword">boolean</span> containsDollarMarker = sqlRewriteContext.getSqlStatementContext() <span class="keyword">instanceof</span> SelectStatementContext</span><br><span class="line">            &amp;&amp; ((SelectStatementContext) (sqlRewriteContext.getSqlStatementContext())).isContainsDollarParameterMarker();</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeUnits) &#123;</span><br><span class="line">        <span class="comment">// 移除sql中的;号</span></span><br><span class="line">        sql.add(SQLUtils.trimSemicolon(<span class="keyword">new</span> RouteSQLBuilder(sqlRewriteContext, each).toSQL()));</span><br><span class="line">        <span class="keyword">if</span> (containsDollarMarker &amp;&amp; !params.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        params.addAll(getParameters(sqlRewriteContext.getParameterBuilder(), routeContext, each));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用 union all 连接 sql</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQLRewriteUnit(String.join(<span class="string">" UNION ALL "</span>, sql), params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#addSQLRewriteUnits</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSQLRewriteUnits</span><span class="params">(<span class="keyword">final</span> Map&lt;RouteUnit, SQLRewriteUnit&gt; sqlRewriteUnits, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeUnits) &#123;</span><br><span class="line">        <span class="comment">// ☆☆☆☆核心☆☆☆☆ RouteSQLBuilder.toSQL() 改写sql</span></span><br><span class="line">        sqlRewriteUnits.put(each, <span class="keyword">new</span> SQLRewriteUnit(<span class="keyword">new</span> RouteSQLBuilder(sqlRewriteContext, each).toSQL(), getParameters(sqlRewriteContext.getParameterBuilder(), routeContext, each)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.sql.impl.AbstractSQLBuilder#toSQL</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toSQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.getSqlTokens().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getSql();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据sqlToken的startIndex进行排序</span></span><br><span class="line">    Collections.sort(context.getSqlTokens());</span><br><span class="line">    <span class="comment">// 遍历sqlToken替换和组装sql字符串</span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(context.getSql(), <span class="number">0</span>, context.getSqlTokens().get(<span class="number">0</span>).getStartIndex());</span><br><span class="line">    <span class="keyword">for</span> (SQLToken each : context.getSqlTokens()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ComposableSQLToken) &#123;</span><br><span class="line">            result.append(getComposableSQLTokenText((ComposableSQLToken) each));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> SubstitutableColumnNameToken) &#123;</span><br><span class="line">            result.append(((SubstitutableColumnNameToken) each).toString(routeUnit));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// sqlToken本身是包含抽象语法树语法节点的数据，所以可以直接进行组装</span></span><br><span class="line">            result.append(getSQLTokenText(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组装sqlToken之间的连接符</span></span><br><span class="line">        result.append(getConjunctionText(each));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的改写逻辑还是比较简单的，主要就是利用 sqlToken 组装 SQL，因为 sqlToken 本身在生成时就包含语法树的节点数据，所以只需要根据规则进行处理即可，例如分库分表、数据加密。</p>
<h3 id="合并引擎"><a href="#合并引擎" class="headerlink" title="合并引擎"></a>合并引擎</h3><p>在讲合并引擎之前，先简单看一下具体执行查询的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#executeQuery0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;QueryResult&gt; <span class="title">executeQuery0</span><span class="params">(<span class="keyword">final</span> ExecutionContext executionContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 按每个数据源的连接数分组，一个连接下可以包含一个数据源下的多个sql</span></span><br><span class="line">    ExecutionGroupContext&lt;JDBCExecutionUnit&gt; executionGroupContext = createExecutionGroupContext(executionContext);</span><br><span class="line">    <span class="keyword">return</span> executor.getRegularExecutor().executeQuery(executionGroupContext, executionContext.getQueryContext(),</span><br><span class="line">            <span class="keyword">new</span> PreparedStatementExecuteQueryCallback(metaDataContexts.getMetaData().getDatabase(databaseName).getProtocolType(),</span><br><span class="line">                    metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData(), sqlStatement,</span><br><span class="line">                    SQLExecutorExceptionHandler.isExceptionThrown()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.executor.sql.prepare.AbstractExecutionPrepareEngine#prepare</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ExecutionGroupContext&lt;T&gt; <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Map&lt;String, Integer&gt; connectionOffsets, <span class="keyword">final</span> Collection&lt;ExecutionUnit&gt; executionUnits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> ExecutionGroupReportContext reportContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Collection&lt;ExecutionGroup&lt;T&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 按数据原分数</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;ExecutionUnit&gt;&gt; entry : aggregateExecutionUnitGroups(executionUnits).entrySet()) &#123;</span><br><span class="line">        String dataSourceName = entry.getKey();</span><br><span class="line">        <span class="comment">// 按每个数据源的连接数拆分成多执行单元（sql）集合</span></span><br><span class="line">        List&lt;List&lt;ExecutionUnit&gt;&gt; executionUnitGroups = group(entry.getValue());</span><br><span class="line">        ConnectionMode connectionMode = maxConnectionsSizePerQuery &lt; entry.getValue().size() ? ConnectionMode.CONNECTION_STRICTLY : ConnectionMode.MEMORY_STRICTLY;</span><br><span class="line">        <span class="comment">// 按每个数据源的连接数分组，一个连接下可以包含一个数据源下的多个sql</span></span><br><span class="line">        result.addAll(group(dataSourceName, connectionOffsets.getOrDefault(dataSourceName, <span class="number">0</span>), executionUnitGroups, connectionMode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可扩展的装饰器</span></span><br><span class="line">    <span class="keyword">return</span> decorate(routeContext, result, reportContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.executor.kernel.ExecutorEngine#execute</span></span><br><span class="line"><span class="keyword">public</span> &lt;I, O&gt; <span class="function">List&lt;O&gt; <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ExecutionGroupContext&lt;I&gt; executionGroupContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> ExecutorCallback&lt;I, O&gt; firstCallback, <span class="keyword">final</span> ExecutorCallback&lt;I, O&gt; callback, <span class="keyword">final</span> <span class="keyword">boolean</span> serial)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executionGroupContext.getInputGroups().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serial ? serialExecute(executionGroupContext.getInputGroups().iterator(), executionGroupContext.getReportContext().getProcessId(), firstCallback, callback)</span><br><span class="line">            : parallelExecute(executionGroupContext.getInputGroups().iterator(), executionGroupContext.getReportContext().getProcessId(), firstCallback, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行逻辑主要包括两部分：</p>
<ol>
<li>根据数据库和单库最大连接数 (maxConnectionsSizePerQuery) 对执行单元进行分组</li>
<li>根据分组后的执行单元并发执行，以求最大的执行效率（分布式事务串行执行）</li>
</ol>
<p>接下来看看合并引擎相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#mergeQuery</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">mergeQuery</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 合并引擎，包括分片合并、数据脱敏、数据加密</span></span><br><span class="line">    MergeEngine mergeEngine = <span class="keyword">new</span> MergeEngine(metaDataContexts.getMetaData().getDatabase(databaseName),</span><br><span class="line">            metaDataContexts.getMetaData().getProps(), connection.getDatabaseConnectionManager().getConnectionContext());</span><br><span class="line">    <span class="keyword">return</span> mergeEngine.merge(queryResults, sqlStatementContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#merge</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MergedResult <span class="title">merge</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 分片结果合并</span></span><br><span class="line">    Optional&lt;MergedResult&gt; mergedResult = executeMerge(queryResults, sqlStatementContext);</span><br><span class="line">    <span class="comment">// 结果处理，数据脱敏、数据解密</span></span><br><span class="line">    Optional&lt;MergedResult&gt; result = mergedResult.isPresent() ? Optional.of(decorate(mergedResult.get(), sqlStatementContext)) : decorate(queryResults.get(<span class="number">0</span>), sqlStatementContext);</span><br><span class="line">    <span class="keyword">return</span> result.orElseGet(() -&gt; <span class="keyword">new</span> TransparentMergedResult(queryResults.get(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#executeMerge</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Optional&lt;MergedResult&gt; <span class="title">executeMerge</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, ResultProcessEngine&gt; entry : engines.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() <span class="keyword">instanceof</span> ResultMergerEngine) &#123;</span><br><span class="line">            ResultMerger resultMerger = ((ResultMergerEngine) entry.getValue()).newInstance(database.getName(), database.getProtocolType(), entry.getKey(), props, sqlStatementContext);</span><br><span class="line">            <span class="keyword">return</span> Optional.of(resultMerger.merge(queryResults, sqlStatementContext, database, connectionContext));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.ShardingDQLResultMerger#build</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">build</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap, <span class="keyword">final</span> ShardingSphereDatabase database)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String defaultSchemaName = <span class="keyword">new</span> DatabaseTypeRegistry(selectStatementContext.getDatabaseType()).getDefaultSchemaName(database.getName());</span><br><span class="line">    ShardingSphereSchema schema = selectStatementContext.getTablesContext().getSchemaName()</span><br><span class="line">            .map(database::getSchema).orElseGet(() -&gt; database.getSchema(defaultSchemaName));</span><br><span class="line">    <span class="comment">// 分组、字段是聚合函数，例如sum()、min()</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessGroupBy(selectStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getGroupByMergedResult(queryResults, selectStatementContext, columnLabelIndexMap, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重 distinct</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessDistinctRow(selectStatementContext)) &#123;</span><br><span class="line">        setGroupByForDistinctRow(selectStatementContext);</span><br><span class="line">        <span class="keyword">return</span> getGroupByMergedResult(queryResults, selectStatementContext, columnLabelIndexMap, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessOrderBy(selectStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderByStreamMergedResult(queryResults, selectStatementContext, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamMergedResult(queryResults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> MergedResult mergedResult, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    MergedResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, ResultProcessEngine&gt; entry : engines.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() <span class="keyword">instanceof</span> ResultDecoratorEngine) &#123;</span><br><span class="line">            <span class="comment">// 获取结果集装饰器</span></span><br><span class="line">            ResultDecorator resultDecorator = getResultDecorator(sqlStatementContext, entry);</span><br><span class="line">            result = <span class="keyword">null</span> == result ? resultDecorator.decorate(mergedResult, sqlStatementContext, entry.getKey()) : resultDecorator.decorate(result, sqlStatementContext, entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == result ? mergedResult : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并引擎主要分为两个部分：</p>
<ol>
<li>查询结果合并，包括聚合、排序、去重、分页</li>
<li>查询结果值处理，包括数据脱敏、解密</li>
</ol>
<p>注意，合并引擎实际只是返回上着做了封装的 MergedResult，具体的合并逻辑实际是在遍历获取结果数据时进行的，下面以排序结果合并为例子，看看合并具体是如何执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.orderby.OrderByStreamMergedResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByStreamMergedResult</span> <span class="keyword">extends</span> <span class="title">StreamMergedResult</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;OrderByItem&gt; orderByItems;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;OrderByValue&gt; orderByValuesQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstNext;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderByStreamMergedResult</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext, <span class="keyword">final</span> ShardingSphereSchema schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        orderByItems = selectStatementContext.getOrderByContext().getItems();</span><br><span class="line">        orderByValuesQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queryResults.size());</span><br><span class="line">        orderResultSetsToQueue(queryResults, selectStatementContext, schema);</span><br><span class="line">        isFirstNext = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orderResultSetsToQueue</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext, <span class="keyword">final</span> ShardingSphereSchema schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (QueryResult each : queryResults) &#123;</span><br><span class="line">            OrderByValue orderByValue = <span class="keyword">new</span> OrderByValue(each, orderByItems, selectStatementContext, schema);</span><br><span class="line">            <span class="keyword">if</span> (orderByValue.next()) &#123;</span><br><span class="line">                orderByValuesQueue.offer(orderByValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setCurrentQueryResult(orderByValuesQueue.isEmpty() ? queryResults.get(<span class="number">0</span>) : orderByValuesQueue.peek().getQueryResult());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFirstNext) &#123;</span><br><span class="line">            isFirstNext = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出排序优先队列中的第一个结果集</span></span><br><span class="line">        OrderByValue firstOrderByValue = orderByValuesQueue.poll();</span><br><span class="line">        <span class="comment">// 如果第一个结果集中存在下一个元素，则将结果集下一个元素中的值复制到OrderByValue中，</span></span><br><span class="line">        <span class="comment">// 然后重新放回优先队列中，从而保证所有结果集的顺序是正确的</span></span><br><span class="line">        <span class="keyword">if</span> (firstOrderByValue.next()) &#123;</span><br><span class="line">            orderByValuesQueue.offer(firstOrderByValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先队列为空则说明遍历到最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取当前顺序最前的元素，但不移除元素</span></span><br><span class="line">        setCurrentQueryResult(orderByValuesQueue.peek().getQueryResult());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.orderby.OrderByValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">OrderByValue</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 移动游标</span></span><br><span class="line">        <span class="keyword">boolean</span> result = queryResult.next();</span><br><span class="line">        <span class="comment">// 将当前游标的排序字段值赋值给orderValues</span></span><br><span class="line">        orderValues = result ? getOrderValues() : Collections.emptyList();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; getOrderValues() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;Comparable&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(orderByItems.size());</span><br><span class="line">        <span class="keyword">for</span> (OrderByItem each : orderByItems) &#123;</span><br><span class="line">            Object value = queryResult.getValue(each.getIndex(), Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            ShardingSpherePreconditions.checkState(<span class="keyword">null</span> == value || value <span class="keyword">instanceof</span> Comparable, () -&gt; <span class="keyword">new</span> NotImplementComparableValueException(<span class="string">"Order by"</span>, value));</span><br><span class="line">            result.add((Comparable&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> OrderByValue orderByValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对比多个游标的当前值</span></span><br><span class="line">        <span class="keyword">for</span> (OrderByItem each : orderByItems) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = CompareUtils.compareTo(orderValues.get(i), orderByValue.orderValues.get(i), each.getSegment().getOrderDirection(),</span><br><span class="line">                    each.getSegment().getNullsOrderType(selectStatementContext.getDatabaseType()), orderValuesCaseSensitive.get(i));</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单分析一下排序结果集合并的代码，假设一条查询语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f_id, f_name <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> f_id;</span><br></pre></td></tr></table></figure>

<p>分片路由后需要查询四张表，那么最终就会产生四个结果集，以这个场景为例子看看结果是如何合并的：</p>
<ol>
<li>将各个结果集封装成 OrderByValue，并将结果集的第一个行数据的排序字段赋值给 OrderByValue，OrderByValue 根据结果集赋值的排序字段对比进行排序。</li>
<li>将封装好的 OrderByValue 放入优先队列中，那么最初就是根绝每个结果集的第一个行数据的排序字段进行排序。</li>
<li>在执行 OrderByStreamMergedResult.next 时，实际上就是将优先队列中的第一个结果集取出并将它的游标移动到下一位，并重新将排序字段赋值给 OrderByValue 后放入优先队列中。</li>
<li>然后再返回优先队列中排在第一位的结果集，但不从队列移除，此时该结果集的游标所处位置表示的就是排序最前的行数据。</li>
<li>反复执行 3、4 步骤，直到遍历完所有结果集下的所有行数据，一次保证所有结果集数据的顺序。</li>
</ol>
<p>以上就是排序结果集合并的具体逻辑，如果对其他结果集合并逻辑感兴趣的看看 MergedResult 的其他实现。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://s21.ax1x.com/2024/08/07/pkzCD6x.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>最后再重新看一下这张流程图，可以很清晰的发现代码的设计完全与这张流程图一致，主要流程 SQL 解析 -&gt; 分片路由 -&gt; SQL 改写 -&gt; SQL 执行 -&gt; 结果合并。</p>
<blockquote>
<p>注：由于文章篇幅有限，没有贴完整代码，并且分片路由算法、读写分离负载均衡、加密脱敏、事务相关都未详讲，有兴趣之后再单独拆一篇文章出来详讲。</p>
<p>参考：</p>
<p><a href="https://shardingsphere.apache.org/document/current/cn/reference/architecture/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/reference/architecture/</a></p>
<p><a href="https://juejin.cn/post/7343161077062991882?searchId=20240721230809FB22ACC70520144A6608#heading-28" target="_blank" rel="noopener">https://juejin.cn/post/7343161077062991882?searchId=20240721230809FB22ACC70520144A6608#heading-28</a></p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2024-08-07T15:58:10.989Z" itemprop="dateUpdated">2024-08-07 23:58:10</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://example.com">
            <img src="/img/avatar.jpg" alt="Jerry Chan">
            Jerry Chan
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&title=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&pic=http://example.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&title=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&via=http://example.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2024/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1-opentelemetry-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0-traceId-%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">记一次 opentelemetry 日志打印 traceId 缺失问题分析</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Jerry Chan &copy; 2023 - 2024</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&title=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&pic=http://example.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&title=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《一个查询语句在 ShardingJDBC 中都发生了啥》 — Jerry Chan&url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/&via=http://example.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAT4AAAE+CAAAAAAxUyPsAAAFMklEQVR42u3bwW7dOBAEQP//TyfA3gLHdnePlMOidDL89CiqGMDNGebjI75+/Xd9/jm556v7P3/3+yuf5+f7v59z+5T6wocPHz58+OKpJxz3T796Yj6ry0JuT8eHDx8+fPgufJewkkw3CQfJaNsTk2VoFwYfPnz48OF7my9//BaMknGSMkRbMtjKIvjw4cOHD9+/Dy7bxvveMMjLDZcR8OHDhw8fvvf42mCRPzLBzVvXSTPg/qxXeh348OHDhw/f+YDa//Xnhy98+PDhw4cvbiTfw0r+9K1wv7XY27Dyl2/hw4cPHz58i0B0dGwreecl+y1zte35S2ljnAQ+fPjw4cMXlAO2hnELlyzbpVCet/YThy9HxocPHz58+M58eUN6a2AnL1ls2s+N8C2i4cOHDx8+fC1f8od5+znZrj91mKzdxecN8qhMjw8fPnz48JV8eVt6K7i3v7/EqRaojVB/3IkPHz58+PAd+JKNettcz8ffmtZtIzwfLVpmfPjw4cOHb+JrA0HezL4X1tvCRFvUOLXz8eHDhw8fvgPf5YjYVgrfSuf5gl0WMpo5Pnz48OHDt/jUL9yGhjZGbE3xvM2QL0Y+W3z48OHDhy/h2/7k35vl0XpODfW2JXD6d4cPHz58+PBNkaUNK5dJbw3svI2dB6BLcMGHDx8+fPie5Ws3/5e4czk0llwf8dUWTfDhw4cPH76n+PKHXaZ7v/IFux8UOOU+fPjw4cOH7zChrTndHlnbEN8epyjZ48OHDx8+fJ/e+n7UuwXKt/fbBv6pIBUVTfDhw4cPH76H+PKksx0Qvxz1rrfxwcjbUXh8+PDhw4fvXldvi9ft5PJmfPvc/FtboInCED58+PDhw1eW6Z89Uvb97/M72xdLjrVt5Q98+PDhw4fvWb52W94eKG9DTHsoPA8r7fvWiQ8fPnz48OH79n8SbQHi/t+fLtEneYvtu1F5Ah8+fPjw4Zv47oe6noogG3pbILi02Nf+OT58+PDhw/cz33bg7Fd5be3z/J6tTR4FI3z48OHDh+/A92zLfDuIlnyaL8kFsS4Z4MOHDx8+fAFf/kf60pzOi+n5OElMeWrZ8OHDhw8fvvf48rJ4EhfurfSkHPBUCz9fbHz48OHDh+/Cd2lCt6WHZDEuzfhLUf4UgPDhw4cPH77gWe2Brba4cAkxlzB0L2pE4QYfPnz48OEr+bakk79Y3qLeyuXtMbU8SBUxCB8+fPjw4TvwtUPkEWF7+Te2+lsb/oc2OT58+PDhwxfz5RD3svt23K3d2D9VYqh7Hfjw4cOHD1/c5700rS+Lcb+zLb63B/LqxIcPHz58+PAFkSWZdB4CtqDTguZzvgSvH0ISPnz48OHD99Df3DwWJNB5a7xuVMcF93b+P7wFPnz48OHDd+bLY0rOtMWaS2v8XviI5oYPHz58+PCVfG0s2KZ44dsWL49TWxkFHz58+PDh2/jy4nV+1GxrPN8JLuWJLTDhw4cPHz58G18+uSRMbEuSRJ9tnh8PXX8ZDR8+fPjw4TvzJaGhbaVvoaeNTSeIreWADx8+fPjwXbvDRZH9cswr2pCfW+ljISCeAz58+PDhw7fx5cXxfFt+v38LQJeRx0/x4cOHDx++ia8l2Erh92J9G7C2e4oiCD58+PDhw/cP+bYNedtEb+fTzup00A0fPnz48OF7je/tIkKCksepvNWdfPfLT/Hhw4cPH76JLz80lkeBHH37zRst8Pp+fPjw4cOHb7k/KrK39+TH2toxt3GS727H7/Dhw4cPH76A7zcmwUykBH0RMwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '大爷别走呀！';
            clearTimeout(titleTime);
        } else {
            document.title = '来啦，老弟!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
