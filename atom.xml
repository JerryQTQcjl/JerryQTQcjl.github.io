<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jerry Chan</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-11-16T17:02:07.892Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jerry Chan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次 docker 文件挂载宿主机修改未同步容器问题</title>
    <link href="http://example.com/2024/11/17/%E8%AE%B0%E4%B8%80%E6%AC%A1-docker-%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BF%AE%E6%94%B9%E6%9C%AA%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2024/11/17/%E8%AE%B0%E4%B8%80%E6%AC%A1-docker-%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%BF%AE%E6%94%B9%E6%9C%AA%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E9%97%AE%E9%A2%98/</id>
    <published>2024-11-16T17:01:14.000Z</published>
    <updated>2024-11-16T17:02:07.892Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用 docker 挂载文件时，发现一个问题，在宿主机更新挂载文件，容器内并未同步。但是重启容器后，容器内又更新了文件。</p><h3 id="容器举个例子"><a href="#容器举个例子" class="headerlink" title="容器举个例子"></a>容器举个例子</h3><p>以下以 nginx 容器举个例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">my-nginx</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/docker-compose/nginx/nginx.conf:/etc/nginx/conf.d/default.conf</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/docker-compose/nginx/index.html:/usr/share/nginx/html/index.html</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"80:80"</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"443:443"</span></span><br></pre></td></tr></table></figure><p>输出容器内 nginx index 页面内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> my-nginx cat /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>修改宿主机上 index 页面内容</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>再次查看容器内 index 页面内容，发现内容并未同步更新。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> my-nginx cat /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</span><br><span class="line">working. Further configuration is required.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;For online documentation and support please refer to</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.org/"</span>&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</span><br><span class="line">Commercial support is available at</span><br><span class="line">&lt;a href=<span class="string">"http://nginx.com/"</span>&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>Docker 挂载文件时，挂载的是文件的 <a href="https://zh.wikipedia.org/wiki/Inode" target="_blank" rel="noopener">inode</a>，而不是路径。当你用 Vim 编辑并保存文件时，它会创建一个新文件并替换原文件，从而改变 inode。由于 inode 改变，容器内的文件没有更新。重启容器时，会挂载新的 inode。</p><p>接下来验证一下，首先先重启下容器，让原本的更新生效。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> my-nginx cat /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>接下来查看一下宿主机 index.html 的 inode，可以看到 inode 值 = 5349362</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stat</span> index.html</span><br><span class="line"></span><br><span class="line">  文件：index.html</span><br><span class="line">  大小：298           块：8          IO 块：4096   普通文件</span><br><span class="line">设备：略    Inode：5349362     硬链接：1</span><br><span class="line">权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">最近访问：2024-11-17 00:17:02.430672510 +0800</span><br><span class="line">最近更改：2024-11-17 00:16:59.236639833 +0800</span><br><span class="line">最近改动：2024-11-17 00:16:59.238639854 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure><p>再看一下容器里 index.html 的 inode，可以看到 inode 值和宿主机是一样的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> my-nginx <span class="built_in">stat</span> /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line">  File: /usr/share/nginx/html/index.html</span><br><span class="line">  Size: 298           Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 252,1    Inode: 5349362     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2024-11-16 16:17:02.430672510 +0000</span><br><span class="line">Modify: 2024-11-16 16:16:59.236639833 +0000</span><br><span class="line">Change: 2024-11-16 16:16:59.238639854 +0000</span><br><span class="line"> Birth: 2024-11-16 16:16:59.236639833 +0000</span><br></pre></td></tr></table></figure><p>接下来通过 vi 修改宿主机 index.html 文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World!!!!!!!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>之后再看看宿主机 index.html 对应 inode，发现宿主机的 inode 值已经发生变化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stat index.html</span><br><span class="line"></span><br><span class="line">  文件：index.html</span><br><span class="line">  大小：304           块：8          IO 块：4096   普通文件</span><br><span class="line">设备：略    Inode：4878009     硬链接：1</span><br><span class="line">权限：(0644&#x2F;-rw-r--r--)  Uid：(    0&#x2F;    root)   Gid：(    0&#x2F;    root)</span><br><span class="line">最近访问：2024-11-17 00:40:32.826158500 +0800</span><br><span class="line">最近更改：2024-11-17 00:40:24.556072681 +0800</span><br><span class="line">最近改动：2024-11-17 00:40:24.558072702 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure><p>再看看容器内 index.html 对应 inode 值，发现容器内 inode 值还是旧值。因此，宿主机更新文件内容并未同步到容器内。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> my-nginx <span class="built_in">stat</span> /usr/share/nginx/html/index.html</span><br><span class="line">  </span><br><span class="line">  File: /usr/share/nginx/html/index.html</span><br><span class="line">  Size: 298           Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 252,1    Inode: 5349362     Links: 0</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2024-11-16 16:17:02.430672510 +0000</span><br><span class="line">Modify: 2024-11-16 16:16:59.236639833 +0000</span><br><span class="line">Change: 2024-11-16 16:40:24.558072702 +0000</span><br><span class="line"> Birth: 2024-11-16 16:16:59.236639833 +0000</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>调整宿主机文件权限为 664，网上有些文章写着是需要将文件权限改成 777，亲测，只需要将组权限改成读写既可以，接下来在测试一下。<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">chmod 664 index.html</span><br><span class="line"></span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">html &#123; color-scheme: light dark; &#125;</span><br><span class="line">body &#123; width: 35em; margin: 0 auto;</span><br><span class="line">font-family: Tahoma, Verdana, Arial, sans-serif; &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Hello World!!!&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> using nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stat</span> index.html</span><br><span class="line"></span><br><span class="line">  文件：index.html</span><br><span class="line">  大小：300           块：8          IO 块：4096   普通文件</span><br><span class="line">设备：略    Inode：4878009     硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid：(    0/    root)   Gid：(    0/    root)</span><br><span class="line">最近访问：2024-11-17 00:46:38.674904905 +0800</span><br><span class="line">最近更改：2024-11-17 00:47:00.742129147 +0800</span><br><span class="line">最近改动：2024-11-17 00:47:00.743129157 +0800</span><br><span class="line">创建时间：-</span><br></pre></td></tr></table></figure>可以看见，将文件权限设置成 664 后，可以避免 vi 编辑器更新导致 inode 变更问题。</li><li>使用挂载目录，挂载目录即使文件 inode 发生变更，容器内也能同步新的 inode</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在使用 docker 挂载文件时，发现一个问题，在宿主机更新挂载文件，容器内并未同步。但是重启容器后，容器内又更新了文件。&lt;/p&gt;
&lt;h3 id=&quot;容器举个例子&quot;&gt;&lt;a href=&quot;#容器举个例子&quot; class=&quot;headerlink&quot; title=&quot;容器举个例子&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis 事务</title>
    <link href="http://example.com/2024/09/25/Redis-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2024/09/25/Redis-%E4%BA%8B%E5%8A%A1/</id>
    <published>2024-09-25T01:39:52.000Z</published>
    <updated>2024-09-25T01:50:07.932Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>事务本质就是将一批命令原子性的执行，在事务执行过程中，其他客户端的命令需要等事务执行结束后才能执行。lua 脚本也是事务的一种类型，但是有两个不同点：</p><ul><li>事务执行过程如果非语法错误的错误，例如操作类型错误，那么事务是会继续执行后续命令的，而 lua 是遇到错误就会终止。不过如果是语法错误，执行 EXEC 命令时，事务就会终止。</li><li>事务不支持使用前面的命令的执行结果作为判断条件，而 lua 脚本是支持的，所以 lua 脚本能支持更为复杂的场景</li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下是 Redis 事务相关命令：</p><ul><li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li><li>EXEC：执行事务中的所有操作命令。</li><li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li><li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li><li>UNWATCH：取消WATCH对所有key的监视。</li></ul><p><strong>标准事务执行</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1111111</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) <span class="string">"v1111"</span></span><br><span class="line">2) <span class="string">"v22222"</span></span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">"v1111111"</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">"v1111111"</span></span><br></pre></td></tr></table></figure><p><strong>事务取消</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 11</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 22</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>语法错误，事务执行失败</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; gett k2</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `gett`, with args beginning with: `k2`,</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; gett k2</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `gett`, with args beginning with: `k2`,</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br></pre></td></tr></table></figure><p><strong>运行过程中错误，跳过当前命令，执行后续命令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; zrange k1 0 -1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">4) <span class="string">"v1"</span></span><br><span class="line">5) <span class="string">"v2"</span></span><br></pre></td></tr></table></figure><p><strong>watch 监听命令变更（乐观锁）</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未发生变更场景</span></span><br><span class="line">127.0.0.1:6379&gt; watch k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) <span class="string">"v1"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发生变更场景(值未变更但执行了set命令也算变更)，事务中包含 watch key</span></span><br><span class="line">127.0.0.1:6379&gt; watch k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发生变更场景，事务中不包含 watch key</span></span><br><span class="line">127.0.0.1:6379&gt; watch k1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v11</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>watch 机制保证只要 key 发生了变更，不管是否值是否有变更，或者事务中是否使用到监听的 key，事务都会直接回滚。在其他客户端操作该 key，也是一样会回滚。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/25/pAQh4Qe.png" alt="截图" title="">                </div>                <div class="image-caption">截图</div>            </figure><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><strong>乐观锁</strong></p><p>利用 watch 机制可以实现一些乐观锁操作，例如一些高并发场景可以利用 watch 机制 + 重试实现乐观锁。</p><p><strong>原子执行</strong></p><p>利用事务原子执行的机制，可以实现一些简单的批量命令原子执行。例如顺序平均分配这种无需依赖前面命令结果的业务就可以使用事务，但是如果是权重分配这种，则需要使用 lua 脚本才能实现。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Redis 事务不支持回滚，使用时需要确保命令的正确性</li><li>Redis 事务遇到非语法错误命令，会执行往下执行，使用时需要注意是否符合业务</li><li>Redis 事务不支持使用前面命令的结果作为判断条件，如果业务复杂，建议直接使用 lua 脚本</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;事务本质就是将一批命令原子性的执行，在事务执行过程中，其他客户端的命令需要等事务执行结束后才能执行。lua 脚本也是事务的一种类型，但是有两</summary>
      
    
    
    
    
    <category term="redis" scheme="http://example.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>让本地配置优先于 apollo 配置</title>
    <link href="http://example.com/2024/09/07/%E8%AE%A9%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E4%BA%8E-apollo-%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2024/09/07/%E8%AE%A9%E6%9C%AC%E5%9C%B0%E9%85%8D%E7%BD%AE%E4%BC%98%E5%85%88%E4%BA%8E-apollo-%E9%85%8D%E7%BD%AE/</id>
    <published>2024-09-07T08:55:09.000Z</published>
    <updated>2024-09-07T08:58:07.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>为什么需要让本地配置优先于 apollo 呢？当你在本地调试时，开发环境的配置可能无法满足调试条件，例如要升级 mysql，需要在本地调试访问高版本的 mysql，但开发环境的 mysql 版本较低，或者要本地调试访问一个新版的 rpc 接口，或者是要调试访问一个 mock 接口，为了能满足调试条件而不改动开发环境配置影响其他童鞋使用，需要本地配置优先于 apollo 配置。</p></blockquote><h3 id="apollo-配置加载"><a href="#apollo-配置加载" class="headerlink" title="apollo 配置加载"></a>apollo 配置加载</h3><p>apollo 主要有两类配置源，分别是 ApolloBootstrapPropertySources 和 ApolloPropertySources，ApolloBootstrapPropertySources 主要是提供 bean 工厂初始化时所需的配置参数，例如在 @condition 中使用 apollo 中的配置，ApolloPropertySources 主要供 bean 容器内的 bean 实例使用。</p><p>接下先看看 ApolloBootstrapPropertySources 的加载时机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.ctrip.framework.apollo.spring.boot.ApolloApplicationContextInitializer</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> </span>&#123;</span><br><span class="line">  ConfigurableEnvironment environment = context.getEnvironment();</span><br><span class="line">  <span class="comment">// apollo.bootstrap.enabled = true 才支持</span></span><br><span class="line">  String enabled = environment.getProperty(PropertySourcesConstants.APOLLO_BOOTSTRAP_ENABLED, <span class="string">"false"</span>);</span><br><span class="line">  <span class="keyword">if</span> (!Boolean.valueOf(enabled)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取需要加载的namespaces</span></span><br><span class="line">  String namespaces = environment.getProperty(PropertySourcesConstants.APOLLO_BOOTSTRAP_NAMESPACES, ConfigConsts.NAMESPACE_APPLICATION);</span><br><span class="line">  List&lt;String&gt; namespaceList = NAMESPACE_SPLITTER.splitToList(namespaces);</span><br><span class="line"></span><br><span class="line">  CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(PropertySourcesConstants.APOLLO_BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">  <span class="keyword">for</span> (String namespace : namespaceList) &#123;</span><br><span class="line">    Config config = ConfigService.getConfig(namespace);</span><br><span class="line">    composite.addPropertySource(configPropertySourceFactory.getConfigPropertySource(namespace, config));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加到environment动态配置源的首位</span></span><br><span class="line">  environment.getPropertySources().addFirst(composite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApolloApplicationContextInitializer 实现了 ApplicationContextInitializer，在 SpringApplication#prepareContext 中执行。根据 apollo.bootstrap.enabled 控制是否开启加载，及根据 apollo.bootstrap.namespaces 决定要加载哪些 namespaces。</p><p>接下来看看</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.ctrip.framework.apollo.spring.config.PropertySourcesProcessor</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (INITIALIZED.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    <span class="comment">// 初始化配置源</span></span><br><span class="line">    initializePropertySources();</span><br><span class="line">    <span class="comment">// 初始化热更新相关功能</span></span><br><span class="line">    initializeAutoUpdatePropertiesFeature(beanFactory);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializePropertySources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (environment.getPropertySources().contains(PropertySourcesConstants.APOLLO_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">    <span class="comment">//already initialized</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CompositePropertySource composite = <span class="keyword">new</span> CompositePropertySource(PropertySourcesConstants.APOLLO_PROPERTY_SOURCE_NAME);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//sort by order asc</span></span><br><span class="line">  ImmutableSortedSet&lt;Integer&gt; orders = ImmutableSortedSet.copyOf(NAMESPACE_NAMES.keySet());</span><br><span class="line">  Iterator&lt;Integer&gt; iterator = orders.iterator();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">int</span> order = iterator.next();</span><br><span class="line">    <span class="keyword">for</span> (String namespace : NAMESPACE_NAMES.get(order)) &#123;</span><br><span class="line">      Config config = ConfigService.getConfig(namespace);</span><br><span class="line"></span><br><span class="line">      composite.addPropertySource(configPropertySourceFactory.getConfigPropertySource(namespace, config));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add after the bootstrap property source or to the first</span></span><br><span class="line">  <span class="keyword">if</span> (environment.getPropertySources()</span><br><span class="line">      .contains(PropertySourcesConstants.APOLLO_BOOTSTRAP_PROPERTY_SOURCE_NAME)) &#123;</span><br><span class="line">    environment.getPropertySources()</span><br><span class="line">        .addAfter(PropertySourcesConstants.APOLLO_BOOTSTRAP_PROPERTY_SOURCE_NAME, composite);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    environment.getPropertySources().addFirst(composite);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PropertySourcesProcessor 继承自 BeanFactoryPostProcessor，会在 bean 工厂初始化完成后，bean 扫描前完成配置源的加载，并且配置源会在 ApolloBootstrapPropertySources 之后。</p><h3 id="添加本地配置源"><a href="#添加本地配置源" class="headerlink" title="添加本地配置源"></a>添加本地配置源</h3><p>知道了 apollo 配置源的加载时机和在环境对象的可变配置源集合的位置之后，就能很容易想到，只要在 bean 初始化前在 ApolloBootstrapPropertySources 前添加本地的配置源即可实现本地配置覆盖 apollo 配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    name = &#123;<span class="string">"localCoverApollo"</span>&#125;,</span><br><span class="line">    havingValue = <span class="string">"true"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApolloLocalPropertySourcesProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span>, <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(ApolloLocalPropertySourcesProcessor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> ConfigurableEnvironment environment;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApolloLocalPropertySourcesProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> ClassPathResource(<span class="string">"application.properties"</span>));</span><br><span class="line">            PropertiesPropertySource propertySource = <span class="keyword">new</span> PropertiesPropertySource(<span class="string">"local"</span>, properties);</span><br><span class="line">            <span class="keyword">this</span>.environment.getPropertySources().addFirst(propertySource);</span><br><span class="line">            log.info(<span class="string">"本地配置覆盖apollo配置成功，本地配置：&#123;&#125;"</span>, properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var4) &#123;</span><br><span class="line">            Exception e = var4;</span><br><span class="line">            log.warn(<span class="string">"本地配置覆盖apollo配置失败"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = (ConfigurableEnvironment)environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是具体实现，总体来说还是非常简单的。如果对上面的代码还有疑问，可以研究一下 Enviroment 获取配置的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;为什么需要让本地配置优先于 apollo 呢？当你在本地调试时，开发环境的配置可能无法满足调试条件，例如要升级 mysql，需要在本地调试访问高版本的 mysql，但开发环境的 mysql 版本较低，或者要本地调试访问一个新版的 rpc 接口，或者</summary>
      
    
    
    
    
    <category term="apollo" scheme="http://example.com/tags/apollo/"/>
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>GraalVM + SpringBoot 初探</title>
    <link href="http://example.com/2024/09/03/GraalVM-SpringBoot-%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2024/09/03/GraalVM-SpringBoot-%E5%88%9D%E6%8E%A2/</id>
    <published>2024-09-03T02:27:04.000Z</published>
    <updated>2024-09-03T02:42:00.591Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GraalVM-简介"><a href="#GraalVM-简介" class="headerlink" title="GraalVM 简介"></a>GraalVM 简介</h3><blockquote><p>GraalVM compiles your Java applications ahead of time into standalone binaries. These binaries are smaller, start up to 100x faster, provide peak performance with no warmup, and use less memory and CPU than applications running on a Java Virtual Machine (JVM).</p><p>GraalVM reduces the attack surface of your application. It excludes unused classes, methods, and fields from the application binary. It restricts reflection and other dynamic Java language features to build time only. It does not load any unknown code at run time.</p><p>Popular microservices frameworks such as Spring Boot, Micronaut, Helidon, and Quarkus, and cloud platforms such as Oracle Cloud Infrastructure, Amazon Web Services, Google Cloud Platform, and Microsoft Azure all support GraalVM.</p><p>With profile-guided optimization and the G1 (Garbage-First) garbage collector, you can get lower latency and on-par or better peak performance and throughput compared to applications running on a Java Virtual Machine (JVM).</p><p>You can use the GraalVM JDK just like any other Java Development Kit in your IDE.</p></blockquote><p>以上是来自<a href="https://www.graalvm.org/latest/docs/introduction/" target="_blank" rel="noopener">官网</a>上的介绍，简单来说主要包括几点：</p><ol><li>GraalVM 支持 AOT（Ahead-Of-Time），提前将 Java 应用编译成可执行的二进制文件，相较于编译成字节码由 JVM 即使编译，拥有更快的速度以及更小的内存。</li><li>GraalVM 限制了 Java 的一些动态能力，例如反射、动态代理、java agent等，只允许在构建 Native Image 时使用。（AOT 模式）</li><li>优化 JVM 即时编译（JIT），使用 GraalVM 编译器替换 C2 编译器，提升运行时性能。</li></ol><h3 id="安装-GraalVM"><a href="#安装-GraalVM" class="headerlink" title="安装 GraalVM"></a>安装 GraalVM</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwIZ6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><a href="https://www.graalvm.org/downloads/#" target="_blank" rel="noopener">官网</a>提供了多种下载方式，目前官网只能下载 Java17-22 的版本，如果想要下载其他版本可以到 <a href="https://github.com/graalvm/graalvm-ce-builds/releases?page=2" target="_blank" rel="noopener">github</a> 下载。</p><p>由于本人使用的是 macos，所以就简单介绍下 macos 下的安装方式，流程还是很简单的，其他操作系统可以进行参考官方文档。</p><ol><li>下载对应的 graalvm 版本</li><li>解压之后移动到 /Library/Java/JavaVirtualMachines 目录下<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf graalvm-jdk-&lt;version&gt;_macos-&lt;architecture&gt;.tar.gz</span><br><span class="line">sudo mv graalvm-jdk-&lt;version&gt;_macos-&lt;architecture&gt; /Library/Java/JavaVirtualMachines</span><br></pre></td></tr></table></figure></li><li>添加环境变量</li><li>如果是从 github 下载的低版本还需要进行一下两个步骤:<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  If you are using macOS Catalina and later you may need to remove the quarantine attribute from the bits before you can use them.</span></span><br><span class="line">sudo xattr -r -d com.apple.quarantine path/to/graalvm/folder/</span><br><span class="line"><span class="comment"># 官网下载的是默认自带的</span></span><br><span class="line">gu install native-image</span><br></pre></td></tr></table></figure></li></ol><h3 id="Java-Demo"><a href="#Java-Demo" class="headerlink" title="Java Demo"></a>Java Demo</h3><p>以下是官网提供的和一个纯 Java 应用 Demo:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ylb.explore.graalvm.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, Native World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将 Java 代码编译成字节码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java</span><br></pre></td></tr></table></figure><p>将字节码编译成可执行二进制文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$JAVA_HOME</span>/bin/native-image com.ylb.explore.graalvm.java.HelloWorld HelloWorld</span><br></pre></td></tr></table></figure><p>执行效果</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./HelloWorld                                                                  </span><br><span class="line">Hello, Native World!</span><br></pre></td></tr></table></figure><p>总体还是非常简单的，编译时注意一下类路径即可。</p><h3 id="SpringBoot-Demo"><a href="#SpringBoot-Demo" class="headerlink" title="SpringBoot Demo"></a>SpringBoot Demo</h3><p>接下来看一下一个简单的 SpringBoot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"cost: "</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">showHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">                hello world</span></span><br><span class="line"><span class="string">                template</span></span><br><span class="line"><span class="string">                "</span><span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码提供一个简单的 http 接口，接下来配置下 maven 相关插件，如果是使用 gradle 的话可以参考<a href="https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html" target="_blank" rel="noopener">官方文档</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>windfall-explore-graalvm-spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>21<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>21<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>21<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.main-class</span>&gt;</span>com.ylb.explore.graalvm.spring.boot.DemoApplication<span class="tag">&lt;/<span class="name">project.main-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.graalvm.buildtools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>native-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- imageName用于设置生成的二进制文件名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>$&#123;project.main-class&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>21<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>21<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">compilerArgs</span>&gt;</span>--enable-preview<span class="tag">&lt;/<span class="name">compilerArgs</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接下执行 maven 插件将代码编译成二进制文件:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn native:compile</span><br></pre></td></tr></table></figure><p>这个时候遇到了编译时的第一个坑</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwbJe.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这里真正的提示错误没有高亮，反而是下面的 native-image -cp 语句进行了高亮，异步流程就会错过，这里耽搁了我不少时间🌚，解决方案也很简单，在插件中添加配置参数即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>$&#123;project.main-class&#125;<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加上 mainClass 后，重新执行编译命令，一切都十分顺利</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwXQA.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>经过漫长的等待，终于编译成功，那么不出意外，意外马上就来了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ windfall-explore-graalvm-spring-boot</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___<span class="string">'_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | '</span>_ | <span class="string">'_| | '</span>_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  <span class="string">'  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="string"> =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> :: Spring Boot ::                (v3.3.3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Application run failed</span></span><br><span class="line"><span class="string">org.springframework.boot.AotInitializerNotFoundException: Startup with AOT mode enabled failed: AOT initializer com.ylb.explore.graalvm.spring.boot.DemoApplication__ApplicationContextInitializer could not be found</span></span><br><span class="line"><span class="string">        at org.springframework.boot.SpringApplication.addAotGeneratedInitializerIfNecessary(SpringApplication.java:443)</span></span><br><span class="line"><span class="string">        at org.springframework.boot.SpringApplication.prepareContext(SpringApplication.java:400)</span></span><br><span class="line"><span class="string">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:334)</span></span><br><span class="line"><span class="string">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)</span></span><br><span class="line"><span class="string">        at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)</span></span><br><span class="line"><span class="string">        at com.ylb.explore.graalvm.spring.boot.DemoApplication.main(DemoApplication.java:11)</span></span><br><span class="line"><span class="string">        at java.base@21.0.4/java.lang.invoke.LambdaForm$DMH/sa346b79c.invokeStaticInit(LambdaForm$DMH)</span></span><br></pre></td></tr></table></figure><p>出现这个错误的主要原因是缺少了 spring boot 的 AOT 元文件信息，需要先通过以下命令编译生成 AOT 元文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean compil</span><br><span class="line">mvn spring-boot:process-aot</span><br><span class="line">mvn spring-boot:process-aot</span><br></pre></td></tr></table></figure><p>接下来再执行  mvn native:compile，坐等二进制文件编译完成即可。</p><p>下面对比下使用 jvm 启动和使用二进制文件的耗时:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwjsI.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwvLt.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>虽然没有到达了官网所说的 100 倍那么多，但也这个差距相当恐怖了。</p><p>以上是在本地编译成可执行文件的方式，spring 官方还提供了直接编译构建 docker 镜像的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:build-image -Pnative</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAVwzeP.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/09/03/pAV0po8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>内部是基于 paketobuildpacks/builder-jammy-tiny 和 paketobuildpacks/run-jammy-tiny 构建镜像，底层原理还未了解，但大概率也是作为基础镜像安装相关环境后，编译代码，然后瘦身镜像。这里有一个，请确保 docker 配置了足够多的内存，别问我怎么知道🌚</p><p>这里还有一个比较坑的点，使用 GraalVM 编译好的二进制文件，无法直接使用 JDK 提供的一下工具，例如 jstack、jstat 等等，可能对之前习惯使用这些工具的童鞋来说，是难以接受的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">43203 Main</span><br><span class="line">18475 Launcher</span><br><span class="line">18847 Jps</span><br><span class="line"></span><br><span class="line">$ ps -ef | grep windfall</span><br><span class="line">501 18834 27099   0 10:21AM ttys003    0:00.09 /windfall-common/windfall-explore/windfall-explore-graalvm/windfall-explore-graalvm-spring-boot/target/windfall-explore-graalvm-spring-boot</span><br><span class="line"></span><br><span class="line"><span class="comment"># 甚至会导致进程直接中断，真恐怖</span></span><br><span class="line">$ jstack 19194                                                                                                                                                                  </span><br><span class="line">19194: No such process</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>GraalVM 提供了 AOT 编译器，大大提升了代码启动效率，但同时也大大增加了编译时间。</li><li>GraalVM 限制了 Java 运行时动态加载的特性，可能很多深度使用 Java 动态加载的应用或者工具并不适用。</li><li>GraalVM AOT 编译出来的二进制文件无法使用 JDK 提供的一些监控诊断工具。</li></ul><blockquote><p>参考：</p><p><a href="https://www.graalvm.org/latest/reference-manual/native-image/" target="_blank" rel="noopener">https://www.graalvm.org/latest/reference-manual/native-image/</a></p><p><a href="https://graalvm.github.io/native-build-tools/latest/maven-plugin.html" target="_blank" rel="noopener">https://graalvm.github.io/native-build-tools/latest/maven-plugin.html</a></p><p><a href="https://docs.spring.io/spring-boot/how-to/native-image/developing-your-first-application.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/how-to/native-image/developing-your-first-application.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GraalVM-简介&quot;&gt;&lt;a href=&quot;#GraalVM-简介&quot; class=&quot;headerlink&quot; title=&quot;GraalVM 简介&quot;&gt;&lt;/a&gt;GraalVM 简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;GraalVM compiles your Jav</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nacos spring 热更新</title>
    <link href="http://example.com/2024/08/30/nacos-spring-%E7%83%AD%E6%9B%B4%E6%96%B0/"/>
    <id>http://example.com/2024/08/30/nacos-spring-%E7%83%AD%E6%9B%B4%E6%96%B0/</id>
    <published>2024-08-29T16:05:05.000Z</published>
    <updated>2024-08-29T16:06:10.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>nacos 热更新主要分为全局环境变量热更新和局部 Bean 字段热更新，分别由 @NacosPropertySource 和 @NacosValue 的 autoRefreshed 字段控制，接下来分别看看原理。</p><h3 id="全局环境变量热更新"><a href="#全局环境变量热更新" class="headerlink" title="全局环境变量热更新"></a>全局环境变量热更新</h3><p>全局环境变量热更新由 @NacosPropertySource 的 autoRefreshed 字段控制，接下来看看源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.spring.core.env.NacosPropertySourcePostProcessor#doProcessPropertySource</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doProcessPropertySource</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据注解或者xml配置解析bean对象中配置的配置源</span></span><br><span class="line">        List&lt;NacosPropertySource&gt; nacosPropertySources = buildNacosPropertySources(</span><br><span class="line">                beanName, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add Orderly</span></span><br><span class="line">        <span class="keyword">for</span> (NacosPropertySource nacosPropertySource : nacosPropertySources) &#123;</span><br><span class="line">            <span class="comment">// 将配置源添加到环境对象中</span></span><br><span class="line">            addNacosPropertySource(nacosPropertySource);</span><br><span class="line">            <span class="comment">// 将NacosPropertySource注解中的非空字符串属性和全局配置合并返回</span></span><br><span class="line">            Properties properties = configServiceBeanBuilder</span><br><span class="line">                    .resolveProperties(nacosPropertySource.getAttributesMetadata());</span><br><span class="line">            <span class="comment">// 添加配置变更监听器</span></span><br><span class="line">            addListenerIfAutoRefreshed(nacosPropertySource, properties, environment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.spring.core.env.NacosPropertySourcePostProcessor#addListenerIfAutoRefreshed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addListenerIfAutoRefreshed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> NacosPropertySource nacosPropertySource, <span class="keyword">final</span> Properties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果NacosPropertySource未开启自动刷新，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!nacosPropertySource.isAutoRefreshed()) &#123; <span class="comment">// Disable Auto-Refreshed</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ConfigService configService = nacosServiceFactory.createConfigService(properties);</span><br><span class="line">            Listener listener = <span class="keyword">new</span> AbstractListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String config)</span> </span>&#123;</span><br><span class="line">                    String name = nacosPropertySource.getName();</span><br><span class="line">                    <span class="comment">// 使用新配置数据构建配置员</span></span><br><span class="line">                    NacosPropertySource newNacosPropertySource = <span class="keyword">new</span> NacosPropertySource(</span><br><span class="line">                            dataId, groupId, name, config, type);</span><br><span class="line">                    <span class="comment">// 拷贝旧源配置的元数据</span></span><br><span class="line">                    newNacosPropertySource.copy(nacosPropertySource);</span><br><span class="line">                    MutablePropertySources propertySources = environment</span><br><span class="line">                            .getPropertySources();</span><br><span class="line">                    <span class="comment">// 替换环境对象中的源配置</span></span><br><span class="line">                    propertySources.replace(name, newNacosPropertySource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">      <span class="comment">// 省略部分代码</span></span><br><span class="line">            configService.addListener(dataId, groupId, listener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NacosException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，@NacosPropertySource 的 autoRefreshed 字段仅控制环境对象中的配置源更新。</p><h3 id="局部-Bean-字段热更新"><a href="#局部-Bean-字段热更新" class="headerlink" title="局部 Bean 字段热更新"></a>局部 Bean 字段热更新</h3><p>接下来看看局部 Bean 字段更新，局部 Bean 字段更新主要由  @NacosValue 的 autoRefreshed 字段控制，接下来同样看看源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    doWithFields(bean, beanName);</span><br><span class="line">    doWithMethods(bean, beanName);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#doWithFields</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(<span class="keyword">final</span> Object bean, <span class="keyword">final</span> String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析bean对象中字段的NacosValue注解</span></span><br><span class="line">    ReflectionUtils.doWithFields(bean.getClass(),</span><br><span class="line">            <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">                    NacosValue annotation = getAnnotation(field, NacosValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                    doWithAnnotation(beanName, bean, annotation, field.getModifiers(),</span><br><span class="line">                            <span class="keyword">null</span>, field);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#doWithAnnotation</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWithAnnotation</span><span class="params">(String beanName, Object bean, NacosValue annotation,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> modifiers, Method method, Field field)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 静态字段不处理</span></span><br><span class="line">            <span class="keyword">if</span> (Modifier.isStatic(modifiers)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 开启自动刷新</span></span><br><span class="line">            <span class="keyword">if</span> (annotation.autoRefreshed()) &#123;</span><br><span class="line">              <span class="comment">// 解析占位符</span></span><br><span class="line">                String placeholder = resolvePlaceholder(annotation.value());</span><br><span class="line">        <span class="comment">// 将占位符，bean对象，字段信息等缓存在内存中</span></span><br><span class="line">                NacosValueTarget nacosValueTarget = <span class="keyword">new</span> NacosValueTarget(bean, beanName,</span><br><span class="line">                        method, field, annotation.value());</span><br><span class="line">                put2ListMap(placeholderNacosValueTargetMap, placeholder,</span><br><span class="line">                        nacosValueTarget);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看到，在 Bean 对象初始化前，会解析对象中添加了 @NacosValue 的字段或者方法，并将相关的字段、对象、注解信息缓存在内存中。接下来看看这些字段是如何实现热更新的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.annotation.config.NacosValueAnnotationBeanPostProcessor#onApplicationEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(NacosConfigReceivedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// In to this event receiver, the environment has been updated the</span></span><br><span class="line">        <span class="comment">// latest configuration information, pull directly from the environment</span></span><br><span class="line">        <span class="comment">// fix issue #142</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;NacosValueTarget&gt;&gt; entry : placeholderNacosValueTargetMap</span><br><span class="line">                .entrySet()) &#123;</span><br><span class="line">            String key = environment.resolvePlaceholders(entry.getKey());</span><br><span class="line">            <span class="comment">// 从环境变量中取出，因为环境变量更新是在事件发布之前应用事件发布前完成的</span></span><br><span class="line">            <span class="comment">// 所以此处获取到的值是已经更新完成之后的数据</span></span><br><span class="line">            String newValue = environment.getProperty(key);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;NacosValueTarget&gt; beanPropertyList = entry.getValue();</span><br><span class="line">            <span class="keyword">for</span> (NacosValueTarget target : beanPropertyList) &#123;</span><br><span class="line">              <span class="comment">// 比较新旧数据md5校验和</span></span><br><span class="line">                String md5String = MD5Utils.md5Hex(newValue, <span class="string">"UTF-8"</span>);</span><br><span class="line">                <span class="keyword">boolean</span> isUpdate = !target.lastMD5.equals(md5String);</span><br><span class="line">                <span class="keyword">if</span> (isUpdate) &#123;</span><br><span class="line">                    target.updateLastMD5(md5String);</span><br><span class="line">                    Object evaluatedValue = resolveNotifyValue(target.nacosValueExpr, key, newValue);</span><br><span class="line">                    <span class="comment">// 更新bean对象字段或方法</span></span><br><span class="line">                    <span class="keyword">if</span> (target.method == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setField(target, evaluatedValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        setMethod(target, evaluatedValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，当接收到配置变更事件时，会遍历内存中的需要自动更新的 Bean 字段信息，对比 MD5 校验和，如果发现存在变更，则更新 Bean 字段或方法。（此处存在一个疑问，每接收到一个事件都会遍历所有 Bean 字段信息，效率是否较低？）</p><p>这里还有一个点需要注意，新的配置数据是直接从环境对象中取出的，这也意味着 @NacosValue 字段的自动更新是会受 @NacosPropertySource 自动更新的影响的。如果 @NacosPropertySource  未开启自动更新，即使 @NacosValue 开启自动更新最终还是无法更新。</p><h3 id="更新事件接送"><a href="#更新事件接送" class="headerlink" title="更新事件接送"></a>更新事件接送</h3><p>接下来再来验证一下上面所说的，全局环境变量的更新是局部 Bean 字段更新之前完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.client.config.impl.CacheData#safeNotifyListener</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">safeNotifyListener</span><span class="params">(<span class="keyword">final</span> String dataId, <span class="keyword">final</span> String group, <span class="keyword">final</span> String content, <span class="keyword">final</span> String type,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> String md5, <span class="keyword">final</span> String encryptedDataKey, <span class="keyword">final</span> ManagerListenerWrap listenerWrap)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    NotifyTask job = <span class="keyword">new</span> NotifyTask() &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            ClassLoader myClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            ClassLoader appClassLoader = listener.getClass().getClassLoader();</span><br><span class="line">            ScheduledFuture&lt;?&gt; timeSchedule = <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">                timeSchedule = getNotifyBlockMonitor().schedule(</span><br><span class="line">                        <span class="keyword">new</span> LongNotifyHandler(listener.getClass().getSimpleName(), dataId, group, tenant, md5,</span><br><span class="line">                                notifyWarnTimeout, Thread.currentThread()), notifyWarnTimeout,</span><br><span class="line">                        TimeUnit.MILLISECONDS);</span><br><span class="line">                listenerWrap.inNotifying = <span class="keyword">true</span>;</span><br><span class="line">                listener.receiveConfigInfo(contentTmp);</span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (NacosException ex) &#123;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.event.config.DelegatingEventPublishingListener#receiveConfigInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiveConfigInfo</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    onReceived(content);</span><br><span class="line">    publishEvent(content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.event.config.DelegatingEventPublishingListener#publishEvent</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">    NacosConfigReceivedEvent event = <span class="keyword">new</span> NacosConfigReceivedEvent(configService,</span><br><span class="line">            dataId, groupId, content, configType);</span><br><span class="line">    applicationEventPublisher.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// com.alibaba.nacos.spring.context.event.config.DelegatingEventPublishingListener#onReceived</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onReceived</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        delegate.receiveConfigInfo(content);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，先执行 Nacos 原生监听器的 receiveConfigInfo 方法，再发布应用事件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>@NacosPropertySource 的 autoRefreshed 字段控制全局环境变量的更新。</li><li>@NacosValue 的 autoRefreshed 字段控制局部 Bean 对象字段更新。</li><li>Bean 对象字段更新还是会受到 @NacosPropertySource 的 autoRefreshed 字段的影响，只有 @NacosPropertySource 和 @NacosValue 同时开启自动刷新才能真正自动更新。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;nacos 热更新主要分为全局环境变量热更新和局部 Bean 字段热更新，分别由 @NacosPropertySource 和 @Nacos</summary>
      
    
    
    
    
    <category term="nacos" scheme="http://example.com/tags/nacos/"/>
    
  </entry>
  
  <entry>
    <title>一个查询语句在 ShardingJDBC 中都发生了啥</title>
    <link href="http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/"/>
    <id>http://example.com/2024/08/07/%E4%B8%80%E4%B8%AA%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%9C%A8-ShardingJDBC-%E4%B8%AD%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5/</id>
    <published>2024-08-07T15:44:48.000Z</published>
    <updated>2024-08-07T15:58:10.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着业务数据的增长，原本公司中的分库分表方案相对来说不够灵活，所以决定引入业内相对较为成熟的分库分表组件。通过接入成本、性能损耗、社区活跃等多方面考虑，决定引入 SharidngJDBC。但是目前 ShardingJDBC 对部分现有业务无法做到太友好的支持，所以决定基于现有扩展点扩展或者改造源码，为此需要深入阅读 ShardingJDBC 源码。</p></blockquote><h3 id="ShardingJDBC-架构图"><a href="#ShardingJDBC-架构图" class="headerlink" title="ShardingJDBC 架构图"></a>ShardingJDBC 架构图</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/08/07/pkzCD6x.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上是从官网拷贝的架构图，图上可以很清晰的看到 SQL 大致流程:</p><ol><li>解析引擎进行 SQL 解析，根据数据库类型将 SQL 解析成抽象语法树</li><li>路由引擎根据路由规则和抽象语法树，生成路由上下文</li><li>改写引擎根据路由上下文和抽象语法树，对 SQL 进行改写，并生成改写上下文</li><li>根据路由上下文、改写上下文生成执行上下文</li><li>执行引擎执行上下文根据库、连接数等进行分组，并发执行 SQL</li><li>合并引擎根据路由规则等对执行结果进行合并等。</li></ol><p>以上是 SQL 大致的执行流程，接下来就从源码层面大致看一下具体执行流程。注：本文是基于 5.5.0 的源码。</p><h3 id="解析引擎"><a href="#解析引擎" class="headerlink" title="解析引擎"></a>解析引擎</h3><p>首先看一下 SQL 解析是在哪个阶段执行，再看看具体解析的逻辑。以下是 SQL 解析执行的阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理语句</span></span><br><span class="line">PreparedStatement preparedStatement = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.connection.ShardingSphereConnection#prepareStatement</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShardingSpherePreparedStatement(<span class="keyword">this</span>, sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#ShardingSpherePreparedStatement</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ShardingSpherePreparedStatement</span><span class="params">(<span class="keyword">final</span> ShardingSphereConnection connection, <span class="keyword">final</span> String sql,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> <span class="keyword">int</span> resultSetType, <span class="keyword">final</span> <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">final</span> <span class="keyword">int</span> resultSetHoldability, <span class="keyword">final</span> <span class="keyword">boolean</span> returnGeneratedKeys,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">final</span> String[] columns)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">    SQLParserRule sqlParserRule = metaDataContexts.getMetaData().getGlobalRuleMetaData().getSingleRule(SQLParserRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 获取 sql 解析引擎</span></span><br><span class="line">    SQLParserEngine sqlParserEngine = sqlParserRule.getSQLParserEngine(metaDataContexts.getMetaData().getDatabase(connection.getDatabaseName()).getProtocolType());</span><br><span class="line">    <span class="comment">// 可以通过 SQLParserRuleConfiguration 配置缓存</span></span><br><span class="line">    sqlStatement = sqlParserEngine.parse(<span class="keyword">this</span>.sql, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    sqlStatementContext = <span class="keyword">new</span> SQLBindEngine(metaDataContexts.getMetaData(), connection.getDatabaseName(), hintValueContext).bind(sqlStatement, Collections.emptyList());</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述可以看到 SQL 解析是在预处理阶段执行的，除了 SQL 解析预处理阶段还初始化了内核处理器，各种执行器等等。</p><p>接下来看看 SQL 解析具体是如何执行的，SQL 解析底层依赖于 Antlr4 (不了解的可以看看这边文章 <a href="https://juejin.cn/post/7396247820900352035" target="_blank" rel="noopener">传送门</a> )：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.parser.sql.SQLStatementParserEngine#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果缓存中存在sql对应的 SQLStatement 则直接从缓存中获取，底层使用的 caffeine</span></span><br><span class="line">    <span class="keyword">return</span> useCache ? sqlStatementCache.get(sql) : sqlStatementParserExecutor.parse(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.parser.sql.SQLStatementParserExecutor#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、基于 Antlr4 语法规则生成抽象语法树</span></span><br><span class="line">    <span class="comment">// 2、基于 Antlr4 vistor 生成 SQLStatement</span></span><br><span class="line">    <span class="keyword">return</span> visitorEngine.visit(parserEngine.parse(sql, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.api.SQLParserEngine#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParseASTNode <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">boolean</span> useCache)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通常是优先从缓存中取，如果有则使用缓存，没有则解析</span></span><br><span class="line">    <span class="keyword">return</span> useCache ? parseTreeCache.get(sql) : sqlParserExecutor.parse(sql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.core.database.parser.SQLParserExecutor#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ParseASTNode <span class="title">parse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    ParseASTNode result = twoPhaseParse(sql);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ParseASTNode <span class="title">twoPhaseParse</span><span class="params">(<span class="keyword">final</span> String sql)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基于SPI获取数据库解析器门面，其中包含语法解析器和词法解析器类型</span></span><br><span class="line">    DialectSQLParserFacade sqlParserFacade = DatabaseTypedSPILoader.getService(DialectSQLParserFacade<span class="class">.<span class="keyword">class</span>, <span class="title">databaseType</span>)</span>;</span><br><span class="line">    <span class="comment">// 初始化语法解析器，此处语法解析器是扩展自 Antlr4 生成的代码</span></span><br><span class="line">    SQLParser sqlParser = SQLParserFactory.newInstance(sql, sqlParserFacade.getLexerClass(), sqlParserFacade.getParserClass());</span><br><span class="line">    ((Parser) sqlParser).getInterpreter().setPredictionMode(PredictionMode.SLL);</span><br><span class="line">    <span class="keyword">return</span> (ParseASTNode) sqlParser.parse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 SQL 解析的具体解析逻辑，底层使用 Antlr4，主要是分为两个阶段：</p><ol><li>使用 Antlr4 生成的语法解析器解析 SQL，生成抽象语法树</li><li>使用自定义的 Vistor 遍历抽象语法树，并生成对应的 SQLStatement</li></ol><p>下面再简单看看 ShardingJDBC 是如何使用 Antlr4 的，具体代码在 shardingsphere-parser 这个模块。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/08/07/pkzCrX6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以 MySQL Insert 语句的语法规则为例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">grammar</span> <span class="string">DMLStatement;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">import</span> <span class="string">BaseRule;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">insert</span></span><br><span class="line">    : INSERT insertSpecification INTO? tableName partitionNames? (insertValuesClause | setAssignmentsClause | insertSelectClause) onDuplicateKeyClause?</span><br><span class="line">    <span class="attr">;</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">insertSpecification</span></span><br><span class="line">    : (LOW_PRIORITY | DELAYED | HIGH_PRIORITY)? IGNORE?</span><br><span class="line">    <span class="attr">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">insertValuesClause</span></span><br><span class="line">    : (LP_ fields? RP_ )? (VALUES | VALUE) (assignmentValues (COMMA_ assignmentValues)* | rowConstructorList) valueReference?</span><br><span class="line">    <span class="attr">;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/08/07/pkzCynK.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.shardingsphere.sql.parser.mysql.parser.MySQLParser#parse</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ASTNode <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// execute 是根据 Antlr4 生成的语法规则，tokenStream 是词法解析器解析出来的 Token 流</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParseASTNode(execute(), (CommonTokenStream) getTokenStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是抽象语法树解析相关的内容，可以看到主要就是使用 Antlr4 的语法规则文件生成语法解析相关的代码:</p><ul><li>execute 是 MySQL 语法解析的总入口，定义在 MySQLStatement.g4 中。</li><li>getTokenStream 是获取词法解析器解析出的 TokenStream。</li><li>parse 方法实际上做的就是将 Antlr4 解析出的抽象语法树和 TokenStream 封装起来，用于后续 Visitor 遍历使用。</li></ul><p>接下来再看看 SQLStatement 生成的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.api.SQLStatementVisitorEngine#visit</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLStatement <span class="title">visit</span><span class="params">(<span class="keyword">final</span> ParseASTNode parseASTNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 visitor, visitor 继承自 Antlr 生成代码</span></span><br><span class="line">    SQLStatementVisitor visitor = SQLStatementVisitorFactory.newInstance(databaseType, SQLVisitorRule.valueOf(parseASTNode.getRootNode().getClass()));</span><br><span class="line">    <span class="comment">// 遍历语法树，生成 SQLStatement</span></span><br><span class="line">    ASTNode result = parseASTNode.getRootNode().accept(visitor);</span><br><span class="line">    appendSQLComments(parseASTNode, result);</span><br><span class="line">    <span class="keyword">return</span> (SQLStatement) result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sql.parser.mysql.visitor.statement.MySQLStatementVisitor#visitInsert</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ASTNode <span class="title">visitInsert</span><span class="params">(<span class="keyword">final</span> InsertContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO :FIXME, since there is no segment for insertValuesClause, InsertStatement is created by sub rule.</span></span><br><span class="line">    MySQLInsertStatement result;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.insertValuesClause()) &#123;</span><br><span class="line">        <span class="comment">// 根据 insert value 语法生成 Statemen</span></span><br><span class="line">        result = (MySQLInsertStatement) visit(ctx.insertValuesClause());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.insertSelectClause()) &#123;</span><br><span class="line">        <span class="comment">// 根据 insert select 语法生成 Statemen</span></span><br><span class="line">        result = (MySQLInsertStatement) visit(ctx.insertSelectClause());</span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">        <span class="comment">// assignment </span></span><br><span class="line">        result = <span class="keyword">new</span> MySQLInsertStatement();</span><br><span class="line">        result.setSetAssignment((SetAssignmentSegment) visit(ctx.setAssignmentsClause()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理 on duplicate</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != ctx.onDuplicateKeyClause()) &#123;</span><br><span class="line">        result.setOnDuplicateKeyColumns((OnDuplicateKeyColumnsSegment) visit(ctx.onDuplicateKeyClause()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置表名</span></span><br><span class="line">    result.setTable((SimpleTableSegment) visit(ctx.tableName()));</span><br><span class="line">    <span class="comment">// 这个暂时不知道作用</span></span><br><span class="line">    result.addParameterMarkerSegments(getParameterMarkerSegments());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Visitor 的作用主要就是自定义遍历抽象语法树的逻辑，Antlr4 定义的每个语法规则都会生成一个 visit 方法，为了方便理解，可以简单的认为每个节点都会生成一个 visit 方法，visit 方法的入参是抽象语法树的根节点，传入的如果是非叶子节点（子节点）则遍历的是子树。</p><p>接下来简单分析一下 visitInsert 方法：</p><ul><li>visitInsert 是 Insert 语法子树的入口，当执行 parseASTNode.getRootNode().accept(visitor) 会从 visitExecute 开始执行，最终执行到 visitInsert。</li><li>如果 insertValuesClause 子树不为空，则遍历 insertValuesClause 子树。</li><li>如果 insertSelectClause 子树不为空，则遍历 insertSelectClause 子树。</li><li>其他步骤大多类似，最终将遍历各个子树的结果 (Statement) 组装成  Statement 返回。</li></ul><h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><p>接下来看一下执行查询相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultSet <span class="title">executeQuery</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建查询上下文</span></span><br><span class="line">        QueryContext queryContext = createQueryContext();</span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        handleAutoCommit(queryContext);</span><br><span class="line">        <span class="comment">// 流量治理相关？暂时不知道作用</span></span><br><span class="line">        trafficInstanceId = getInstanceIdAndSet(queryContext).orElse(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != trafficInstanceId) &#123;</span><br><span class="line">            JDBCExecutionUnit executionUnit = createTrafficExecutionUnit(trafficInstanceId, queryContext);</span><br><span class="line">            <span class="keyword">return</span> executor.getTrafficExecutor().execute(executionUnit, (statement, sql) -&gt; ((PreparedStatement) statement).executeQuery());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// todo 联邦查询相关</span></span><br><span class="line">        useFederation = decide(queryContext,</span><br><span class="line">                metaDataContexts.getMetaData().getDatabase(databaseName), metaDataContexts.getMetaData().getGlobalRuleMetaData());</span><br><span class="line">        <span class="keyword">if</span> (useFederation) &#123;</span><br><span class="line">            <span class="keyword">return</span> executeFederationQuery(queryContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建执行上下文</span></span><br><span class="line">        executionContext = createExecutionContext(queryContext);</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        result = doExecuteQuery(executionContext);</span><br><span class="line">        <span class="comment">// CHECKSTYLE:OFF</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> RuntimeException ex) &#123;</span><br><span class="line">        <span class="comment">// CHECKSTYLE:ON</span></span><br><span class="line">        handleExceptionInTransaction(connection, metaDataContexts);</span><br><span class="line">        <span class="keyword">throw</span> SQLExceptionTransformEngine.toSQLException(ex, metaDataContexts.getMetaData().getDatabase(databaseName).getProtocolType());</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#createExecutionContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExecutionContext <span class="title">createExecutionContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext)</span> </span>&#123;</span><br><span class="line">    RuleMetaData globalRuleMetaData = metaDataContexts.getMetaData().getGlobalRuleMetaData();</span><br><span class="line">    ShardingSphereDatabase currentDatabase = metaDataContexts.getMetaData().getDatabase(databaseName);</span><br><span class="line">    <span class="comment">// sql 审计检查</span></span><br><span class="line">    SQLAuditEngine.audit(queryContext.getSqlStatementContext(), queryContext.getParameters(), globalRuleMetaData, currentDatabase, <span class="keyword">null</span>, queryContext.getHintValueContext());</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 生成执行上下文</span></span><br><span class="line">    ExecutionContext result = kernelProcessor.generateExecutionContext(</span><br><span class="line">            queryContext, currentDatabase, globalRuleMetaData, metaDataContexts.getMetaData().getProps(), connection.getDatabaseConnectionManager().getConnectionContext());</span><br><span class="line">    findGeneratedKey(result).ifPresent(optional -&gt; generatedValues.addAll(optional.getGeneratedValues()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#doExecuteQuery</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ShardingSphereResultSet <span class="title">doExecuteQuery</span><span class="params">(<span class="keyword">final</span> ExecutionContext executionContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    List&lt;QueryResult&gt; queryResults = executeQuery0(executionContext);</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 合并结果、加密、脱敏</span></span><br><span class="line">    MergedResult mergedResult = mergeQuery(queryResults, executionContext.getSqlStatementContext());</span><br><span class="line">    List&lt;ResultSet&gt; resultSets = getResultSets();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == columnLabelAndIndexMap) &#123;</span><br><span class="line">        columnLabelAndIndexMap = ShardingSphereResultSetUtils.createColumnLabelAndIndexMap(sqlStatementContext, selectContainsEnhancedTable, resultSets.get(<span class="number">0</span>).getMetaData());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ShardingSphereResultSet(resultSets, mergedResult, <span class="keyword">this</span>, selectContainsEnhancedTable, executionContext, columnLabelAndIndexMap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.connection.kernel.KernelProcessor#generateExecutionContext</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExecutionContext <span class="title">generateExecutionContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> RuleMetaData globalRuleMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路由，包括分片、读写分离、数据源匹配等等</span></span><br><span class="line">    <span class="comment">// 根据查询上下文、数据库对象、全局规则元数据等参数进行路由，得到路由上下文</span></span><br><span class="line">    RouteContext routeContext = route(queryContext, database, globalRuleMetaData, props, connectionContext);</span><br><span class="line">    <span class="comment">// 根据路由结果改写sql</span></span><br><span class="line">    <span class="comment">// 根据路由上下文和其他参数，对查询语句进行改写，得到改写结果</span></span><br><span class="line">    SQLRewriteResult rewriteResult = rewrite(queryContext, database, globalRuleMetaData, props, routeContext, connectionContext);</span><br><span class="line">    <span class="comment">// 根据查询上下文、数据库对象、路由上下文、改写结果等信息创建执行上下文</span></span><br><span class="line">    ExecutionContext result = createExecutionContext(queryContext, database, routeContext, rewriteResult);</span><br><span class="line">    logSQL(queryContext, props, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行查询主要的逻辑包括执行上下文的创建，以及具体执行查询逻辑。其中联邦查询逻辑由于是实验特性，之后再详看。</p><ul><li>执行上下文创建主要包括 SQL 审计、分片路由（分库分表、读写分离、影子库）、SQL 改写（分库分表改写、数据加密）</li><li>具体执行逻辑主要包括执行上下文分组、根据分组并发执行、查询结果合并（分片结果合并、分页结果合并、数据脱敏、数据加密）</li></ul><h3 id="SQL-审计引擎"><a href="#SQL-审计引擎" class="headerlink" title="SQL 审计引擎"></a>SQL 审计引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span>(access = AccessLevel.PRIVATE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SQLAuditEngine</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(<span class="keyword">final</span> SQLStatementContext sqlStatementContext, <span class="keyword">final</span> List&lt;Object&gt; params,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> Grantee grantee, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">        Collection&lt;ShardingSphereRule&gt; rules = <span class="keyword">new</span> LinkedList&lt;&gt;(globalRuleMetaData.getRules());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != database) &#123;</span><br><span class="line">            rules.addAll(database.getRuleMetaData().getRules());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据分片规则获取对应的审计规则</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLAuditor&gt; entry : OrderedSPILoader.getServices(SQLAuditor<span class="class">.<span class="keyword">class</span>, <span class="title">rules</span>).<span class="title">entrySet</span>()) </span>&#123;</span><br><span class="line">            entry.getValue().audit(sqlStatementContext, params, grantee, globalRuleMetaData, database, entry.getKey(), hintValueContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>审计规则比较简单，主要就是基于 SPI 获取规则对应的审计规则，例如默认的分片审计规则不允许 SQL 中没有分片条件。</p><h3 id="路由引擎"><a href="#路由引擎" class="headerlink" title="路由引擎"></a>路由引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.route.engine.impl.PartialSQLRouteExecutor#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">route</span><span class="params">(<span class="keyword">final</span> ConnectionContext connectionContext, <span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database)</span> </span>&#123;</span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    <span class="comment">// 强制路由库</span></span><br><span class="line">    Optional&lt;String&gt; dataSourceName = findDataSourceByHint(queryContext.getHintValueContext(), database.getResourceMetaData().getStorageUnits());</span><br><span class="line">    <span class="keyword">if</span> (dataSourceName.isPresent()) &#123;</span><br><span class="line">        result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(dataSourceName.get(), dataSourceName.get()), Collections.emptyList()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 装饰器装饰路由上下文，这里的 routers 根据配置的规则而确定，例如 shardingRule，readWriteSplitRule 都会有对应的 routers</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLRouter&gt; entry : routers.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.getRouteUnits().isEmpty()) &#123;</span><br><span class="line">            result = entry.getValue().createRouteContext(queryContext, globalRuleMetaData, database, entry.getKey(), props, connectionContext);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry.getValue().decorateRouteContext(result, queryContext, database, entry.getKey(), props, connectionContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.getRouteUnits().isEmpty() &amp;&amp; <span class="number">1</span> == database.getResourceMetaData().getStorageUnits().size()) &#123;</span><br><span class="line">        String singleDataSourceName = database.getResourceMetaData().getStorageUnits().keySet().iterator().next();</span><br><span class="line">        result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(singleDataSourceName, singleDataSourceName), Collections.emptyList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析下上面的代码：</p><ul><li>如果是强制路由数据库，则直接返回。</li><li>根据规则获取 SQLRouter，SQLRouter 由 SPI 加载，其中包括单表、分库分表、广播、读写分离影子库等多种 SQLRouter。</li><li>SQLRouter 采用装饰器模式，SQLRouter 中定义了优先级，优先级最高的 SQLRouter 创建路由上下文，之后的 SQLRouter 负责装饰路由上下文。</li></ul><p>接下来看一下分库分表和读写分离，其他的感兴趣的可以自行看看源码，首先看一下分库分表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.ShardingSQLRouter#createRouteContext0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RouteContext <span class="title">createRouteContext0</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData, <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> ShardingRule rule,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取查询上下文中的 sql 语句</span></span><br><span class="line">    SQLStatement sqlStatement = queryContext.getSqlStatementContext().getSqlStatement();</span><br><span class="line">    <span class="comment">// 解析分片条件</span></span><br><span class="line">    ShardingConditions shardingConditions = createShardingConditions(queryContext, globalRuleMetaData, database, rule);</span><br><span class="line">    <span class="comment">// todo 校验 sql 语句</span></span><br><span class="line">    Optional&lt;ShardingStatementValidator&gt; validator = ShardingStatementValidatorFactory.newInstance(sqlStatement, shardingConditions, globalRuleMetaData);</span><br><span class="line">    validator.ifPresent(optional -&gt; optional.preValidate(rule, queryContext.getSqlStatementContext(), queryContext.getParameters(), database, props));</span><br><span class="line">    <span class="comment">// 包含子查询需要合并分片条件</span></span><br><span class="line">    <span class="keyword">if</span> (sqlStatement <span class="keyword">instanceof</span> DMLStatement &amp;&amp; shardingConditions.isNeedMerge()) &#123;</span><br><span class="line">        <span class="comment">// 合并查询条件</span></span><br><span class="line">        shardingConditions.merge();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据sql语句类型，路由规则等获取分片引擎，并分片</span></span><br><span class="line">    RouteContext result = ShardingRouteEngineFactory.newInstance(rule, database, queryContext, shardingConditions, props, connectionContext, globalRuleMetaData)</span><br><span class="line">            .route(rule);</span><br><span class="line">    <span class="comment">// todo 后置校验</span></span><br><span class="line">    validator.ifPresent(optional -&gt; optional.postValidate(rule, queryContext.getSqlStatementContext(), queryContext.getHintValueContext(), queryContext.getParameters(), database, props, result));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是 ShardingSQLRouter 创建路由上下文的逻辑，主要包括：</p><ul><li>根据分片规则解析分表条件，包括分片表、分片字段、字段值。</li><li>SQL 语句校验。</li><li>根据分片规则创建对应的分片路由引擎，并创建路由上下文。</li></ul><p>下面看看最简单的分片规则路由引擎 (ShardingStandardRoutingEngine) 是怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">route</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule)</span> </span>&#123;</span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 根据规则，获取数据节点</span></span><br><span class="line">    Collection&lt;DataNode&gt; dataNodes = getDataNodes(shardingRule, shardingRule.getShardingTable(logicTableName));</span><br><span class="line">    result.getOriginalDataNodes().addAll(originalDataNodes);</span><br><span class="line">    <span class="keyword">for</span> (DataNode each : dataNodes) &#123;</span><br><span class="line">        <span class="comment">// 以路由单位进行封装，封装逻辑库与实际库映射，逻辑表与实际表映射</span></span><br><span class="line">        result.getRouteUnits().add(</span><br><span class="line">                <span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(each.getDataSourceName(), each.getDataSourceName()), Collections.singleton(<span class="keyword">new</span> RouteMapper(logicTableName, each.getTableName()))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#getDataNodes</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">getDataNodes</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ShardingTable shardingTable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据规则获取数据库分片策略</span></span><br><span class="line">    ShardingStrategy databaseShardingStrategy = createShardingStrategy(shardingRule.getDatabaseShardingStrategyConfiguration(shardingTable),</span><br><span class="line">            shardingRule.getShardingAlgorithms(), shardingRule.getDefaultShardingColumn());</span><br><span class="line">    <span class="comment">// 根据规则获取表分片策略</span></span><br><span class="line">    ShardingStrategy tableShardingStrategy = createShardingStrategy(shardingRule.getTableShardingStrategyConfiguration(shardingTable),</span><br><span class="line">            shardingRule.getShardingAlgorithms(), shardingRule.getDefaultShardingColumn());</span><br><span class="line">    <span class="comment">// 强制路由</span></span><br><span class="line">    <span class="keyword">if</span> (isRoutingByHint(shardingRule, shardingTable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> routeByHint(shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 条件路由</span></span><br><span class="line">    <span class="keyword">if</span> (isRoutingByShardingConditions(shardingRule, shardingTable)) &#123;</span><br><span class="line">        <span class="keyword">return</span> routeByShardingConditions(shardingRule, shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 混合强制路由和条件路由，库和表分片其中一个是强制路由</span></span><br><span class="line">    <span class="keyword">return</span> routeByMixedConditions(shardingRule, shardingTable, databaseShardingStrategy, tableShardingStrategy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#routeByShardingConditionsWithCondition</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">routeByShardingConditionsWithCondition</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ShardingTable shardingTable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                                        <span class="keyword">final</span> ShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> ShardingStrategy tableShardingStrategy)</span> </span>&#123;</span><br><span class="line">    Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 根据分片条件路由，获取数据节点</span></span><br><span class="line">    <span class="keyword">for</span> (ShardingCondition each : shardingConditions.getConditions()) &#123;</span><br><span class="line">        Collection&lt;DataNode&gt; dataNodes = route0(shardingTable,</span><br><span class="line">                databaseShardingStrategy, getShardingValuesFromShardingConditions(shardingRule, databaseShardingStrategy.getShardingColumns(), each),</span><br><span class="line">                tableShardingStrategy, getShardingValuesFromShardingConditions(shardingRule, tableShardingStrategy.getShardingColumns(), each));</span><br><span class="line">        result.addAll(dataNodes);</span><br><span class="line">        originalDataNodes.add(dataNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.engine.type.standard.ShardingStandardRoutingEngine#route0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;DataNode&gt; <span class="title">route0</span><span class="params">(<span class="keyword">final</span> ShardingTable shardingTable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> ShardingStrategy databaseShardingStrategy, <span class="keyword">final</span> List&lt;ShardingConditionValue&gt; databaseShardingValues,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> ShardingStrategy tableShardingStrategy, <span class="keyword">final</span> List&lt;ShardingConditionValue&gt; tableShardingValues)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路由到对应数据库</span></span><br><span class="line">    Collection&lt;String&gt; routedDataSources = routeDataSources(shardingTable, databaseShardingStrategy, databaseShardingValues);</span><br><span class="line">    Collection&lt;DataNode&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 路由到对应表</span></span><br><span class="line">    <span class="keyword">for</span> (String each : routedDataSources) &#123;</span><br><span class="line">        result.addAll(routeTables(shardingTable, each, tableShardingStrategy, tableShardingValues));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.strategy.type.standard.StandardShardingStrategy#doSharding</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> Collection&lt;ShardingConditionValue&gt; shardingConditionValues,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">final</span> DataNodeInfo dataNodeInfo, <span class="keyword">final</span> ConfigurationProperties props)</span> </span>&#123;</span><br><span class="line">    ShardingConditionValue shardingConditionValue = shardingConditionValues.iterator().next();</span><br><span class="line">    <span class="comment">// 根据分片列是精确查询还是范围查询调用对应的处理方法</span></span><br><span class="line">    Collection&lt;String&gt; shardingResult = shardingConditionValue <span class="keyword">instanceof</span> ListShardingConditionValue</span><br><span class="line">            ? doSharding(availableTargetNames, (ListShardingConditionValue) shardingConditionValue, dataNodeInfo)</span><br><span class="line">            : doSharding(availableTargetNames, (RangeShardingConditionValue) shardingConditionValue, dataNodeInfo);</span><br><span class="line">    Collection&lt;String&gt; result = <span class="keyword">new</span> TreeSet&lt;&gt;(String.CASE_INSENSITIVE_ORDER);</span><br><span class="line">    result.addAll(shardingResult);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.route.strategy.type.standard.StandardShardingStrategy#doSharding</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; availableTargetNames, <span class="keyword">final</span> ListShardingConditionValue&lt;?&gt; shardingValue, <span class="keyword">final</span> DataNodeInfo dataNodeInfo)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Object each : shardingValue.getValues()) &#123;</span><br><span class="line">        <span class="comment">// 这里就是我们指定的或者自定义的分片算法</span></span><br><span class="line">        String target = shardingAlgorithm.doSharding(availableTargetNames,</span><br><span class="line">                <span class="keyword">new</span> PreciseShardingValue(shardingValue.getTableName(), shardingValue.getColumnName(), dataNodeInfo, each));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != target &amp;&amp; availableTargetNames.contains(target)) &#123;</span><br><span class="line">            result.add(target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != target &amp;&amp; !availableTargetNames.contains(target)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ShardingRouteAlgorithmException(target, availableTargetNames);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来简单分析一下，上述代码是以分片条件进行路由：</p><ul><li>路由上下文主要是由一组路由单元组成，路由单元中主要包括库映射和表映射。</li><li>路由主要包括库路由和表路由，其中包括强制路由、分片路由、混合强制路由（库强制标条件或者库条件表强制）。</li><li>路由的可用数据节点 (DataNodes) 是根据表分片规则的 AcutalDataNode 解析的。</li><li>根据我们分片规则指定的分片算法进行路由，路由主要包括等值条件路由和范围条件路由。</li><li>如果 SQL 没有分片条件，则进行全库表路由。</li></ul><p>接下来看看读写分离的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingSQLRouter#createRouteContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RouteContext <span class="title">createRouteContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RuleMetaData globalRuleMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">final</span> ShardingSphereDatabase database, <span class="keyword">final</span> ReadwriteSplittingRule rule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ReadwriteSplittingSQLRouter在所有SQLRouter中排最后一位，如果是创建路由上下文则说明当前SQL未匹配其他路由条件</span></span><br><span class="line">    RouteContext result = <span class="keyword">new</span> RouteContext();</span><br><span class="line">    ReadwriteSplittingDataSourceRule singleDataSourceRule = rule.getSingleDataSourceRule();</span><br><span class="line">    <span class="comment">// 直接使用ReadwriteSplittingDataSourceRouter来进行路由</span></span><br><span class="line">    String dataSourceName = <span class="keyword">new</span> ReadwriteSplittingDataSourceRouter(singleDataSourceRule, connectionContext).route(queryContext.getSqlStatementContext(), queryContext.getHintValueContext());</span><br><span class="line">    result.getRouteUnits().add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(singleDataSourceRule.getName(), dataSourceName), Collections.emptyList()));</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingSQLRouter#decorateRouteContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorateRouteContext</span><span class="params">(<span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> ShardingSphereDatabase database,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">final</span> ReadwriteSplittingRule rule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    Collection&lt;RouteUnit&gt; toBeRemoved = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Collection&lt;RouteUnit&gt; toBeAdded = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeContext.getRouteUnits()) &#123;</span><br><span class="line">        <span class="comment">// 获取逻辑库对应的读写分离规则，如果逻辑库存在对应规则，并且路由单元的实际库等于读写分离规则名</span></span><br><span class="line">        String dataSourceName = each.getDataSourceMapper().getLogicName();</span><br><span class="line">        Optional&lt;ReadwriteSplittingDataSourceRule&gt; dataSourceRule = rule.findDataSourceRule(dataSourceName);</span><br><span class="line">        <span class="keyword">if</span> (dataSourceRule.isPresent() &amp;&amp; dataSourceRule.get().getName().equalsIgnoreCase(each.getDataSourceMapper().getActualName())) &#123;</span><br><span class="line">            toBeRemoved.add(each);</span><br><span class="line">            <span class="comment">// 重新构建路由单元</span></span><br><span class="line">            String actualDataSourceName = <span class="keyword">new</span> ReadwriteSplittingDataSourceRouter(dataSourceRule.get(), connectionContext).route(queryContext.getSqlStatementContext(),</span><br><span class="line">                    queryContext.getHintValueContext());</span><br><span class="line">            toBeAdded.add(<span class="keyword">new</span> RouteUnit(<span class="keyword">new</span> RouteMapper(each.getDataSourceMapper().getLogicName(), actualDataSourceName), each.getTableMappers()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    routeContext.getRouteUnits().removeAll(toBeRemoved);</span><br><span class="line">    routeContext.getRouteUnits().addAll(toBeAdded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingDataSourceRouter#route</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">route</span><span class="params">(<span class="keyword">final</span> SQLStatementContext sqlStatementContext, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (QualifiedReadwriteSplittingDataSourceRouter each : getQualifiedRouters(connectionContext)) &#123;</span><br><span class="line">        <span class="comment">// 1、写操作、上锁、强制写 2、事务</span></span><br><span class="line">        <span class="keyword">if</span> (each.isQualified(sqlStatementContext, rule, hintValueContext)) &#123;</span><br><span class="line">            <span class="keyword">return</span> each.route(rule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 负载均衡到从库（过滤禁用从库）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardReadwriteSplittingDataSourceRouter().route(rule);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.readwritesplitting.route.ReadwriteSplittingDataSourceRouter#getQualifiedRouters</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;QualifiedReadwriteSplittingDataSourceRouter&gt; <span class="title">getQualifiedRouters</span><span class="params">(<span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、QualifiedReadwriteSplittingPrimaryDataSourceRouter 写操作、上锁、强制路由路由主库</span></span><br><span class="line">    <span class="comment">// 2、QualifiedReadwriteSplittingTransactionalDataSourceRouter 事务默认路由主库，FIXED、DYNAMIC策略读从库(过滤禁用的从库)</span></span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> QualifiedReadwriteSplittingPrimaryDataSourceRouter(), <span class="keyword">new</span> QualifiedReadwriteSplittingTransactionalDataSourceRouter(connectionContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>读写分离路由器主要分为创建路由单元和装饰路由单元</li><li>由于读写分离路由器在所有路由器中排在最后一位，如果是创建路由单元说明其他路由规则都没有匹配到，此时直接使用 ReadwriteSplittingDataSourceRouter 进行路由</li><li>如果是装饰路由上下文，则遍历路由单元，如果匹配上读写分离规则则重新使用 ReadwriteSplittingDataSourceRouter 进行路由后覆盖原本的路由单元</li><li>ReadwriteSplittingDataSourceRouter 主要是根据以下两个条件判断是否读主库<ul><li>写操作、上锁、强制路由路由主库</li><li>事务默认路由主库，FIXED、DYNAMIC策略读从库(过滤禁用的从库)</li><li>其他情况都是负载均衡到从库（具体负载均衡规则是我们自己指定的）</li></ul></li></ul><h3 id="改写引擎"><a href="#改写引擎" class="headerlink" title="改写引擎"></a>改写引擎</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#rewrite</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SQLRewriteResult <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ☆☆☆☆核心☆☆☆☆ 创建sql改写上下文，包括sqlToken的生成</span></span><br><span class="line">    SQLRewriteContext sqlRewriteContext = createSQLRewriteContext(queryContext, routeContext, connectionContext);</span><br><span class="line">    SQLTranslatorRule rule = globalRuleMetaData.getSingleRule(SQLTranslatorRule<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 改写，根据是否有路由单元选择对应的改写引擎</span></span><br><span class="line">    <span class="keyword">return</span> routeContext.getRouteUnits().isEmpty()</span><br><span class="line">            ? <span class="keyword">new</span> GenericSQLRewriteEngine(rule, database, globalRuleMetaData).rewrite(sqlRewriteContext, queryContext)</span><br><span class="line">            : <span class="keyword">new</span> RouteSQLRewriteEngine(rule, database, globalRuleMetaData).rewrite(sqlRewriteContext, routeContext, queryContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 改写主要有两个部分组成：</p><ol><li>SQL 改写上下文的创建，包括 sqlToken 的生成，sqlToken 主要用于改写 SQL。</li><li>根据路由上下文和 SQL 改写上下文进行改写。</li></ol><p>接下来先看一下 SQL 改写上下文的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#createSQLRewriteContext</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLRewriteContext <span class="title">createSQLRewriteContext</span><span class="params">(<span class="keyword">final</span> QueryContext queryContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> ConnectionContext connectionContext)</span> </span>&#123;</span><br><span class="line">    HintValueContext hintValueContext = queryContext.getHintValueContext();</span><br><span class="line">    SQLRewriteContext result = <span class="keyword">new</span> SQLRewriteContext(database, queryContext.getSqlStatementContext(), queryContext.getSql(), queryContext.getParameters(), connectionContext, hintValueContext);</span><br><span class="line">    <span class="comment">// 装饰sql改写上下文</span></span><br><span class="line">    decorate(decorators, result, routeContext, hintValueContext);</span><br><span class="line">    <span class="comment">// 生成 sqlToken，sqlToken 主要是针对sql语句的各个分段进行改写，例如表名、字段、字段值等等</span></span><br><span class="line">    result.generateSQLTokens();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.SQLRewriteEntry#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> Map&lt;ShardingSphereRule, SQLRewriteContextDecorator&gt; decorators, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> HintValueContext hintValueContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 强制路由可以绕过改写</span></span><br><span class="line">    <span class="keyword">if</span> (hintValueContext.isSkipSQLRewrite()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, SQLRewriteContextDecorator&gt; entry : decorators.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// ☆☆☆☆核心☆☆☆☆ 基于装饰器扩展点，可以添加一些自己需要的sqlToken，用于扩展改写sql</span></span><br><span class="line">        entry.getValue().decorate(entry.getKey(), props, sqlRewriteContext, routeContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.context.ShardingSQLRewriteContextDecorator#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> ShardingRule shardingRule, <span class="keyword">final</span> ConfigurationProperties props, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext)</span> </span>&#123;</span><br><span class="line">    SQLStatementContext sqlStatementContext = sqlRewriteContext.getSqlStatementContext();</span><br><span class="line">    <span class="keyword">if</span> (sqlStatementContext <span class="keyword">instanceof</span> InsertStatementContext &amp;&amp; !containsShardingTable(shardingRule, sqlStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!sqlRewriteContext.getParameters().isEmpty()) &#123;</span><br><span class="line">        Collection&lt;ParameterRewriter&gt; parameterRewriters =</span><br><span class="line">                <span class="keyword">new</span> ShardingParameterRewriterBuilder(shardingRule, routeContext, sqlRewriteContext.getDatabase().getSchemas(), sqlStatementContext).getParameterRewriters();</span><br><span class="line">        rewriteParameters(sqlRewriteContext, parameterRewriters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加sqlToken构建器</span></span><br><span class="line">    sqlRewriteContext.addSQLTokenGenerators(<span class="keyword">new</span> ShardingTokenGenerateBuilder(shardingRule, routeContext, sqlStatementContext).getSQLTokenGenerators());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.token.ShardingTokenGenerateBuilder#getSQLTokenGenerators</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;SQLTokenGenerator&gt; <span class="title">getSQLTokenGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;SQLTokenGenerator&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> TableTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> DistinctProjectionPrefixTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ProjectionsTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> OrderByTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> AggregationDistinctTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> IndexTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ConstraintTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> OffsetTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> RowCountTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyInsertColumnTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyForUseDefaultInsertColumnsTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyAssignmentTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ShardingInsertValuesTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> GeneratedKeyInsertValuesTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> ShardingRemoveTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> CursorTokenGenerator());</span><br><span class="line">    addSQLTokenGenerator(result, <span class="keyword">new</span> FetchDirectionTokenGenerator());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.rewrite.token.generator.impl.TableTokenGenerator#generateSQLTokens</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;SQLToken&gt; <span class="title">generateSQLTokens</span><span class="params">(<span class="keyword">final</span> TableAvailable sqlStatementContext)</span> </span>&#123;</span><br><span class="line">    Collection&lt;SQLToken&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SimpleTableSegment each : sqlStatementContext.getAllTables()) &#123;</span><br><span class="line">        TableNameSegment tableName = each.getTableName();</span><br><span class="line">        <span class="keyword">if</span> (shardingRule.findShardingTable(tableName.getIdentifier().getValue()).isPresent()) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> TableToken(tableName.getStartIndex(), tableName.getStopIndex(), tableName.getIdentifier(), (SQLStatementContext) sqlStatementContext, shardingRule));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SQL 改写上下文的创建最主要就是创建 sqlToken，其中可以分为几个步骤：</p><ol><li><p>根据规则获取 SQL 改写上下文装饰器，主要包括分片规则和数据加密装饰器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decorators = OrderedSPILoader.getServices(SQLRewriteContextDecorator<span class="class">.<span class="keyword">class</span>, <span class="title">database</span>.<span class="title">getRuleMetaData</span>().<span class="title">getRules</span>())</span>;</span><br></pre></td></tr></table></figure></li><li><p>装饰器主要作用就是添加 sqlToken 构建器。</p></li><li><p>统一生成 sqlToken，sqlToken 主要是针对 SQL 语句的各个分段进行改写，例如表名、字段、字段值等等。以 TableToken 为例，TableToken 从 SQL 解析出来的 TableStatement 中获取到表名的起始结束位置，改写时就是利用字符串截取替换起始结束位置之间的字符串。</p></li></ol><p>接下来看一下具体的改写逻辑实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#rewrite</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> RouteSQLRewriteResult <span class="title">rewrite</span><span class="params">(<span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> QueryContext queryContext)</span> </span>&#123;</span><br><span class="line">    Map&lt;RouteUnit, SQLRewriteUnit&gt; sqlRewriteUnits = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(routeContext.getRouteUnits().size(), <span class="number">1F</span>);</span><br><span class="line">    <span class="comment">// 根据数据库分组</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, Collection&lt;RouteUnit&gt;&gt; entry : aggregateRouteUnitGroups(routeContext.getRouteUnits()).entrySet()) &#123;</span><br><span class="line">        Collection&lt;RouteUnit&gt; routeUnits = entry.getValue();</span><br><span class="line">        <span class="comment">// 同一个库的查询语句，且不包含子查询、关联查询、排序、分页、锁</span></span><br><span class="line">        <span class="keyword">if</span> (isNeedAggregateRewrite(sqlRewriteContext.getSqlStatementContext(), routeUnits)) &#123;</span><br><span class="line">            <span class="comment">// 用 union all 连接 sql</span></span><br><span class="line">            sqlRewriteUnits.put(routeUnits.iterator().next(), createSQLRewriteUnit(sqlRewriteContext, routeContext, routeUnits));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 改写sql后封装成sql改写单元</span></span><br><span class="line">            addSQLRewriteUnits(sqlRewriteUnits, sqlRewriteContext, routeContext, routeUnits);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻译SQL，官方暂未提供实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RouteSQLRewriteResult(translate(queryContext, sqlRewriteUnits));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#createSQLRewriteUnit</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> SQLRewriteUnit <span class="title">createSQLRewriteUnit</span><span class="params">(<span class="keyword">final</span> SQLRewriteContext sqlRewriteContext, <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits)</span> </span>&#123;</span><br><span class="line">    Collection&lt;String&gt; sql = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;Object&gt; params = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 参数是否是$开头</span></span><br><span class="line">    <span class="keyword">boolean</span> containsDollarMarker = sqlRewriteContext.getSqlStatementContext() <span class="keyword">instanceof</span> SelectStatementContext</span><br><span class="line">            &amp;&amp; ((SelectStatementContext) (sqlRewriteContext.getSqlStatementContext())).isContainsDollarParameterMarker();</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeUnits) &#123;</span><br><span class="line">        <span class="comment">// 移除sql中的;号</span></span><br><span class="line">        sql.add(SQLUtils.trimSemicolon(<span class="keyword">new</span> RouteSQLBuilder(sqlRewriteContext, each).toSQL()));</span><br><span class="line">        <span class="keyword">if</span> (containsDollarMarker &amp;&amp; !params.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        params.addAll(getParameters(sqlRewriteContext.getParameterBuilder(), routeContext, each));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用 union all 连接 sql</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SQLRewriteUnit(String.join(<span class="string">" UNION ALL "</span>, sql), params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.engine.RouteSQLRewriteEngine#addSQLRewriteUnits</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSQLRewriteUnits</span><span class="params">(<span class="keyword">final</span> Map&lt;RouteUnit, SQLRewriteUnit&gt; sqlRewriteUnits, <span class="keyword">final</span> SQLRewriteContext sqlRewriteContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Collection&lt;RouteUnit&gt; routeUnits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (RouteUnit each : routeUnits) &#123;</span><br><span class="line">        <span class="comment">// ☆☆☆☆核心☆☆☆☆ RouteSQLBuilder.toSQL() 改写sql</span></span><br><span class="line">        sqlRewriteUnits.put(each, <span class="keyword">new</span> SQLRewriteUnit(<span class="keyword">new</span> RouteSQLBuilder(sqlRewriteContext, each).toSQL(), getParameters(sqlRewriteContext.getParameterBuilder(), routeContext, each)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.rewrite.sql.impl.AbstractSQLBuilder#toSQL</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toSQL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.getSqlTokens().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> context.getSql();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据sqlToken的startIndex进行排序</span></span><br><span class="line">    Collections.sort(context.getSqlTokens());</span><br><span class="line">    <span class="comment">// 遍历sqlToken替换和组装sql字符串</span></span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(context.getSql(), <span class="number">0</span>, context.getSqlTokens().get(<span class="number">0</span>).getStartIndex());</span><br><span class="line">    <span class="keyword">for</span> (SQLToken each : context.getSqlTokens()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (each <span class="keyword">instanceof</span> ComposableSQLToken) &#123;</span><br><span class="line">            result.append(getComposableSQLTokenText((ComposableSQLToken) each));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (each <span class="keyword">instanceof</span> SubstitutableColumnNameToken) &#123;</span><br><span class="line">            result.append(((SubstitutableColumnNameToken) each).toString(routeUnit));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// sqlToken本身是包含抽象语法树语法节点的数据，所以可以直接进行组装</span></span><br><span class="line">            result.append(getSQLTokenText(each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组装sqlToken之间的连接符</span></span><br><span class="line">        result.append(getConjunctionText(each));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的改写逻辑还是比较简单的，主要就是利用 sqlToken 组装 SQL，因为 sqlToken 本身在生成时就包含语法树的节点数据，所以只需要根据规则进行处理即可，例如分库分表、数据加密。</p><h3 id="合并引擎"><a href="#合并引擎" class="headerlink" title="合并引擎"></a>合并引擎</h3><p>在讲合并引擎之前，先简单看一下具体执行查询的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#executeQuery0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;QueryResult&gt; <span class="title">executeQuery0</span><span class="params">(<span class="keyword">final</span> ExecutionContext executionContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 按每个数据源的连接数分组，一个连接下可以包含一个数据源下的多个sql</span></span><br><span class="line">    ExecutionGroupContext&lt;JDBCExecutionUnit&gt; executionGroupContext = createExecutionGroupContext(executionContext);</span><br><span class="line">    <span class="keyword">return</span> executor.getRegularExecutor().executeQuery(executionGroupContext, executionContext.getQueryContext(),</span><br><span class="line">            <span class="keyword">new</span> PreparedStatementExecuteQueryCallback(metaDataContexts.getMetaData().getDatabase(databaseName).getProtocolType(),</span><br><span class="line">                    metaDataContexts.getMetaData().getDatabase(databaseName).getResourceMetaData(), sqlStatement,</span><br><span class="line">                    SQLExecutorExceptionHandler.isExceptionThrown()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.executor.sql.prepare.AbstractExecutionPrepareEngine#prepare</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ExecutionGroupContext&lt;T&gt; <span class="title">prepare</span><span class="params">(<span class="keyword">final</span> RouteContext routeContext, <span class="keyword">final</span> Map&lt;String, Integer&gt; connectionOffsets, <span class="keyword">final</span> Collection&lt;ExecutionUnit&gt; executionUnits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                  <span class="keyword">final</span> ExecutionGroupReportContext reportContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Collection&lt;ExecutionGroup&lt;T&gt;&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 按数据原分数</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;ExecutionUnit&gt;&gt; entry : aggregateExecutionUnitGroups(executionUnits).entrySet()) &#123;</span><br><span class="line">        String dataSourceName = entry.getKey();</span><br><span class="line">        <span class="comment">// 按每个数据源的连接数拆分成多执行单元（sql）集合</span></span><br><span class="line">        List&lt;List&lt;ExecutionUnit&gt;&gt; executionUnitGroups = group(entry.getValue());</span><br><span class="line">        ConnectionMode connectionMode = maxConnectionsSizePerQuery &lt; entry.getValue().size() ? ConnectionMode.CONNECTION_STRICTLY : ConnectionMode.MEMORY_STRICTLY;</span><br><span class="line">        <span class="comment">// 按每个数据源的连接数分组，一个连接下可以包含一个数据源下的多个sql</span></span><br><span class="line">        result.addAll(group(dataSourceName, connectionOffsets.getOrDefault(dataSourceName, <span class="number">0</span>), executionUnitGroups, connectionMode));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可扩展的装饰器</span></span><br><span class="line">    <span class="keyword">return</span> decorate(routeContext, result, reportContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.executor.kernel.ExecutorEngine#execute</span></span><br><span class="line"><span class="keyword">public</span> &lt;I, O&gt; <span class="function">List&lt;O&gt; <span class="title">execute</span><span class="params">(<span class="keyword">final</span> ExecutionGroupContext&lt;I&gt; executionGroupContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">final</span> ExecutorCallback&lt;I, O&gt; firstCallback, <span class="keyword">final</span> ExecutorCallback&lt;I, O&gt; callback, <span class="keyword">final</span> <span class="keyword">boolean</span> serial)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executionGroupContext.getInputGroups().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serial ? serialExecute(executionGroupContext.getInputGroups().iterator(), executionGroupContext.getReportContext().getProcessId(), firstCallback, callback)</span><br><span class="line">            : parallelExecute(executionGroupContext.getInputGroups().iterator(), executionGroupContext.getReportContext().getProcessId(), firstCallback, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行逻辑主要包括两部分：</p><ol><li>根据数据库和单库最大连接数 (maxConnectionsSizePerQuery) 对执行单元进行分组</li><li>根据分组后的执行单元并发执行，以求最大的执行效率（分布式事务串行执行）</li></ol><p>接下来看看合并引擎相关逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.driver.jdbc.core.statement.ShardingSpherePreparedStatement#mergeQuery</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">mergeQuery</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 合并引擎，包括分片合并、数据脱敏、数据加密</span></span><br><span class="line">    MergeEngine mergeEngine = <span class="keyword">new</span> MergeEngine(metaDataContexts.getMetaData().getDatabase(databaseName),</span><br><span class="line">            metaDataContexts.getMetaData().getProps(), connection.getDatabaseConnectionManager().getConnectionContext());</span><br><span class="line">    <span class="keyword">return</span> mergeEngine.merge(queryResults, sqlStatementContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#merge</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MergedResult <span class="title">merge</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 分片结果合并</span></span><br><span class="line">    Optional&lt;MergedResult&gt; mergedResult = executeMerge(queryResults, sqlStatementContext);</span><br><span class="line">    <span class="comment">// 结果处理，数据脱敏、数据解密</span></span><br><span class="line">    Optional&lt;MergedResult&gt; result = mergedResult.isPresent() ? Optional.of(decorate(mergedResult.get(), sqlStatementContext)) : decorate(queryResults.get(<span class="number">0</span>), sqlStatementContext);</span><br><span class="line">    <span class="keyword">return</span> result.orElseGet(() -&gt; <span class="keyword">new</span> TransparentMergedResult(queryResults.get(<span class="number">0</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#executeMerge</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Optional&lt;MergedResult&gt; <span class="title">executeMerge</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, ResultProcessEngine&gt; entry : engines.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() <span class="keyword">instanceof</span> ResultMergerEngine) &#123;</span><br><span class="line">            ResultMerger resultMerger = ((ResultMergerEngine) entry.getValue()).newInstance(database.getName(), database.getProtocolType(), entry.getKey(), props, sqlStatementContext);</span><br><span class="line">            <span class="keyword">return</span> Optional.of(resultMerger.merge(queryResults, sqlStatementContext, database, connectionContext));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.ShardingDQLResultMerger#build</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">build</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">final</span> Map&lt;String, Integer&gt; columnLabelIndexMap, <span class="keyword">final</span> ShardingSphereDatabase database)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String defaultSchemaName = <span class="keyword">new</span> DatabaseTypeRegistry(selectStatementContext.getDatabaseType()).getDefaultSchemaName(database.getName());</span><br><span class="line">    ShardingSphereSchema schema = selectStatementContext.getTablesContext().getSchemaName()</span><br><span class="line">            .map(database::getSchema).orElseGet(() -&gt; database.getSchema(defaultSchemaName));</span><br><span class="line">    <span class="comment">// 分组、字段是聚合函数，例如sum()、min()</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessGroupBy(selectStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getGroupByMergedResult(queryResults, selectStatementContext, columnLabelIndexMap, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重 distinct</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessDistinctRow(selectStatementContext)) &#123;</span><br><span class="line">        setGroupByForDistinctRow(selectStatementContext);</span><br><span class="line">        <span class="keyword">return</span> getGroupByMergedResult(queryResults, selectStatementContext, columnLabelIndexMap, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">if</span> (isNeedProcessOrderBy(selectStatementContext)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OrderByStreamMergedResult(queryResults, selectStatementContext, schema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IteratorStreamMergedResult(queryResults);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.infra.merge.MergeEngine#decorate</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MergedResult <span class="title">decorate</span><span class="params">(<span class="keyword">final</span> MergedResult mergedResult, <span class="keyword">final</span> SQLStatementContext sqlStatementContext)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    MergedResult result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;ShardingSphereRule, ResultProcessEngine&gt; entry : engines.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (entry.getValue() <span class="keyword">instanceof</span> ResultDecoratorEngine) &#123;</span><br><span class="line">            <span class="comment">// 获取结果集装饰器</span></span><br><span class="line">            ResultDecorator resultDecorator = getResultDecorator(sqlStatementContext, entry);</span><br><span class="line">            result = <span class="keyword">null</span> == result ? resultDecorator.decorate(mergedResult, sqlStatementContext, entry.getKey()) : resultDecorator.decorate(result, sqlStatementContext, entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> == result ? mergedResult : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并引擎主要分为两个部分：</p><ol><li>查询结果合并，包括聚合、排序、去重、分页</li><li>查询结果值处理，包括数据脱敏、解密</li></ol><p>注意，合并引擎实际只是返回上着做了封装的 MergedResult，具体的合并逻辑实际是在遍历获取结果数据时进行的，下面以排序结果合并为例子，看看合并具体是如何执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.orderby.OrderByStreamMergedResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByStreamMergedResult</span> <span class="keyword">extends</span> <span class="title">StreamMergedResult</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;OrderByItem&gt; orderByItems;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;OrderByValue&gt; orderByValuesQueue;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Getter</span>(AccessLevel.PROTECTED)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstNext;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderByStreamMergedResult</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext, <span class="keyword">final</span> ShardingSphereSchema schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        orderByItems = selectStatementContext.getOrderByContext().getItems();</span><br><span class="line">        orderByValuesQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(queryResults.size());</span><br><span class="line">        orderResultSetsToQueue(queryResults, selectStatementContext, schema);</span><br><span class="line">        isFirstNext = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">orderResultSetsToQueue</span><span class="params">(<span class="keyword">final</span> List&lt;QueryResult&gt; queryResults, <span class="keyword">final</span> SelectStatementContext selectStatementContext, <span class="keyword">final</span> ShardingSphereSchema schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (QueryResult each : queryResults) &#123;</span><br><span class="line">            OrderByValue orderByValue = <span class="keyword">new</span> OrderByValue(each, orderByItems, selectStatementContext, schema);</span><br><span class="line">            <span class="keyword">if</span> (orderByValue.next()) &#123;</span><br><span class="line">                orderByValuesQueue.offer(orderByValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setCurrentQueryResult(orderByValuesQueue.isEmpty() ? queryResults.get(<span class="number">0</span>) : orderByValuesQueue.peek().getQueryResult());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isFirstNext) &#123;</span><br><span class="line">            isFirstNext = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出排序优先队列中的第一个结果集</span></span><br><span class="line">        OrderByValue firstOrderByValue = orderByValuesQueue.poll();</span><br><span class="line">        <span class="comment">// 如果第一个结果集中存在下一个元素，则将结果集下一个元素中的值复制到OrderByValue中，</span></span><br><span class="line">        <span class="comment">// 然后重新放回优先队列中，从而保证所有结果集的顺序是正确的</span></span><br><span class="line">        <span class="keyword">if</span> (firstOrderByValue.next()) &#123;</span><br><span class="line">            orderByValuesQueue.offer(firstOrderByValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先队列为空则说明遍历到最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (orderByValuesQueue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取当前顺序最前的元素，但不移除元素</span></span><br><span class="line">        setCurrentQueryResult(orderByValuesQueue.peek().getQueryResult());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// org.apache.shardingsphere.sharding.merge.dql.orderby.OrderByValue</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderByValue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">OrderByValue</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 移动游标</span></span><br><span class="line">        <span class="keyword">boolean</span> result = queryResult.next();</span><br><span class="line">        <span class="comment">// 将当前游标的排序字段值赋值给orderValues</span></span><br><span class="line">        orderValues = result ? getOrderValues() : Collections.emptyList();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Comparable&lt;?&gt;&gt; getOrderValues() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        List&lt;Comparable&lt;?&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(orderByItems.size());</span><br><span class="line">        <span class="keyword">for</span> (OrderByItem each : orderByItems) &#123;</span><br><span class="line">            Object value = queryResult.getValue(each.getIndex(), Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            ShardingSpherePreconditions.checkState(<span class="keyword">null</span> == value || value <span class="keyword">instanceof</span> Comparable, () -&gt; <span class="keyword">new</span> NotImplementComparableValueException(<span class="string">"Order by"</span>, value));</span><br><span class="line">            result.add((Comparable&lt;?&gt;) value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">final</span> OrderByValue orderByValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 对比多个游标的当前值</span></span><br><span class="line">        <span class="keyword">for</span> (OrderByItem each : orderByItems) &#123;</span><br><span class="line">            <span class="keyword">int</span> result = CompareUtils.compareTo(orderValues.get(i), orderByValue.orderValues.get(i), each.getSegment().getOrderDirection(),</span><br><span class="line">                    each.getSegment().getNullsOrderType(selectStatementContext.getDatabaseType()), orderValuesCaseSensitive.get(i));</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != result) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单分析一下排序结果集合并的代码，假设一条查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> f_id, f_name <span class="keyword">from</span> t_user <span class="keyword">order</span> <span class="keyword">by</span> f_id;</span><br></pre></td></tr></table></figure><p>分片路由后需要查询四张表，那么最终就会产生四个结果集，以这个场景为例子看看结果是如何合并的：</p><ol><li>将各个结果集封装成 OrderByValue，并将结果集的第一个行数据的排序字段赋值给 OrderByValue，OrderByValue 根据结果集赋值的排序字段对比进行排序。</li><li>将封装好的 OrderByValue 放入优先队列中，那么最初就是根绝每个结果集的第一个行数据的排序字段进行排序。</li><li>在执行 OrderByStreamMergedResult.next 时，实际上就是将优先队列中的第一个结果集取出并将它的游标移动到下一位，并重新将排序字段赋值给 OrderByValue 后放入优先队列中。</li><li>然后再返回优先队列中排在第一位的结果集，但不从队列移除，此时该结果集的游标所处位置表示的就是排序最前的行数据。</li><li>反复执行 3、4 步骤，直到遍历完所有结果集下的所有行数据，一次保证所有结果集数据的顺序。</li></ol><p>以上就是排序结果集合并的具体逻辑，如果对其他结果集合并逻辑感兴趣的看看 MergedResult 的其他实现。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/08/07/pkzCD6x.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>最后再重新看一下这张流程图，可以很清晰的发现代码的设计完全与这张流程图一致，主要流程 SQL 解析 -&gt; 分片路由 -&gt; SQL 改写 -&gt; SQL 执行 -&gt; 结果合并。</p><blockquote><p>注：由于文章篇幅有限，没有贴完整代码，并且分片路由算法、读写分离负载均衡、加密脱敏、事务相关都未详讲，有兴趣之后再单独拆一篇文章出来详讲。</p><p>参考：</p><p><a href="https://shardingsphere.apache.org/document/current/cn/reference/architecture/" target="_blank" rel="noopener">https://shardingsphere.apache.org/document/current/cn/reference/architecture/</a></p><p><a href="https://juejin.cn/post/7343161077062991882?searchId=20240721230809FB22ACC70520144A6608#heading-28" target="_blank" rel="noopener">https://juejin.cn/post/7343161077062991882?searchId=20240721230809FB22ACC70520144A6608#heading-28</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;随着业务数据的增长，原本公司中的分库分表方案相对来说不够灵活，所以决定引入业内相对较为成熟的分库分表组件。通过接入成本、性能损耗、社区活跃等多方面考虑，决定引入 SharidngJDBC。但是目前 ShardingJDBC 对部分现有业务无法做到太</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记一次 opentelemetry 日志打印 traceId 缺失问题分析</title>
    <link href="http://example.com/2024/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1-opentelemetry-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0-traceId-%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2024/08/05/%E8%AE%B0%E4%B8%80%E6%AC%A1-opentelemetry-%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0-traceId-%E7%BC%BA%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</id>
    <published>2024-08-05T03:51:33.000Z</published>
    <updated>2024-08-05T04:05:40.501Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>背景：项目中有一些消费 kafka 消息者打印的日志中缺失 traceId，项目中使用的是 javaagent 的方式接入 opentelemetry，使用的版本是 1.4.x。 <br/></p></blockquote><h3 id="Kafka-生产者"><a href="#Kafka-生产者" class="headerlink" title="Kafka 生产者"></a>Kafka 生产者</h3><p>首先看看生产者消息发送方法的方法增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodEnter(suppress = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">onEnter</span>(</span></span><br><span class="line">        @Advice.FieldValue("apiVersions") ApiVersions apiVersions,</span><br><span class="line">        <span class="meta">@Advice</span>.Argument(value = <span class="number">0</span>, readOnly = <span class="keyword">false</span>) ProducerRecord&lt;?, ?&gt; record,</span><br><span class="line">        <span class="meta">@Advice</span>.Argument(value = <span class="number">1</span>, readOnly = <span class="keyword">false</span>) Callback callback,</span><br><span class="line">        <span class="meta">@Advice</span>.Local(<span class="string">"otelContext"</span>) Context context,</span><br><span class="line">        <span class="meta">@Advice</span>.Local(<span class="string">"otelScope"</span>) Scope scope) &#123;</span><br><span class="line">      <span class="comment">// 获取当前线程上下文</span></span><br><span class="line">      Context parentContext = Java8BytecodeBridge.currentContext();</span><br><span class="line">      <span class="comment">// 生成 context (包括生成 span)</span></span><br><span class="line">      context = tracer().startProducerSpan(parentContext, record);</span><br><span class="line"></span><br><span class="line">      callback = <span class="keyword">new</span> ProducerCallback(callback, parentContext, context);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 判断是否需要传播链路</span></span><br><span class="line">      <span class="keyword">if</span> (tracer().shouldPropagate(apiVersions)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 往请求头中添加 span 信息</span></span><br><span class="line">          tracer().inject(context, record.headers(), SETTER);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">          <span class="comment">// headers must be read-only from reused record. try again with new one.</span></span><br><span class="line">          record =</span><br><span class="line">              <span class="keyword">new</span> ProducerRecord&lt;&gt;(</span><br><span class="line">                  record.topic(),</span><br><span class="line">                  record.partition(),</span><br><span class="line">                  record.timestamp(),</span><br><span class="line">                  record.key(),</span><br><span class="line">                  record.value(),</span><br><span class="line">                  record.headers());</span><br><span class="line"></span><br><span class="line">          tracer().inject(context, record.headers(), SETTER);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将生成的 context 设置到当前上下文（默认使用threadLocal）</span></span><br><span class="line">      scope = context.makeCurrent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(onThrowable = Throwable<span class="class">.<span class="keyword">class</span>, <span class="title">suppress</span> </span>= Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">stopSpan</span>(</span></span><br><span class="line"><span class="class">        @<span class="title">Advice</span>.<span class="title">Thrown</span> <span class="title">Throwable</span> <span class="title">throwable</span>,</span></span><br><span class="line">        @Advice.Local("otelContext") Context context,</span><br><span class="line">        <span class="meta">@Advice</span>.Local(<span class="string">"otelScope"</span>) Scope scope) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将当前上下文清空，并恢复到父上下文（如果存在的话）</span></span><br><span class="line">      scope.close();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tracer().endExceptionally(context, throwable);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// span finished by ProducerCallback</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="从上述源码可以看到："><a href="#从上述源码可以看到：" class="headerlink" title="从上述源码可以看到："></a>从上述源码可以看到：</h4><ol><li>方法增强会在发送消息前生成 context，如果存在 parentContext 则使用 parentContext 的 traceId。</li><li>如果支持传播，则会将 span 组装好放到消息 header，具体参数名看使用的是什么协议，默认是 traceparent，这里使用 jaeger，所以参数名是 uber-trace-id。</li><li>将生成的 context 设置到当前线程上下文</li><li>消息发送结束时会将线程上下文恢复到原本的上下文</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s21.ax1x.com/2024/08/05/pkvU8Ig.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="Producer-traceId-消息缺失分析"><a href="#Producer-traceId-消息缺失分析" class="headerlink" title="Producer traceId 消息缺失分析"></a>Producer traceId 消息缺失分析</h4><ol><li>由于当前不存在上下文，生产者在发送完消息后就直接将上下文清空了，所以后续打印的日志都不存在上下文</li><li>通过 callback 打印日志，由于 callback 是在另外一个线程执行，所以也获取不到上下文</li></ol><br/><h3 id="Kafka-消费者"><a href="#Kafka-消费者" class="headerlink" title="Kafka 消费者"></a>Kafka 消费者</h3><p>首先看看消费者消息消费方法的方法增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(TypeTransformer transformer)</span> </span>&#123;</span><br><span class="line">    transformer.applyAdviceToMethod(</span><br><span class="line">        isMethod()</span><br><span class="line">            .and(isPublic())</span><br><span class="line">            .and(named(<span class="string">"records"</span>))</span><br><span class="line">            .and(takesArgument(<span class="number">0</span>, String<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">            .<span class="title">and</span>(<span class="title">returns</span>(<span class="title">Iterable</span>.<span class="title">class</span>)),</span></span><br><span class="line">        KafkaConsumerInstrumentation.class.getName() + "$IterableAdvice");</span><br><span class="line">    transformer.applyAdviceToMethod(</span><br><span class="line">        isMethod()</span><br><span class="line">            .and(isPublic())</span><br><span class="line">            .and(named(<span class="string">"records"</span>))</span><br><span class="line">            .and(takesArgument(<span class="number">0</span>, named(<span class="string">"org.apache.kafka.common.TopicPartition"</span>)))</span><br><span class="line">            .and(returns(List<span class="class">.<span class="keyword">class</span>)),</span></span><br><span class="line">        KafkaConsumerInstrumentation.class.getName() + "$ListAdvice");</span><br><span class="line">    transformer.applyAdviceToMethod(</span><br><span class="line">        isMethod()</span><br><span class="line">            .and(isPublic())</span><br><span class="line">            .and(named(<span class="string">"iterator"</span>))</span><br><span class="line">            .and(takesArguments(<span class="number">0</span>))</span><br><span class="line">            .and(returns(Iterator<span class="class">.<span class="keyword">class</span>)),</span></span><br><span class="line">        KafkaConsumerInstrumentation.class.getName() + "$IteratorAdvice");</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IterableAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(suppress = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">wrap</span>(</span></span><br><span class="line"><span class="class">        @<span class="title">Advice</span>.<span class="title">Return</span>(<span class="title">readOnly</span> </span>= <span class="keyword">false</span>) Iterable&lt;ConsumerRecord&lt;?, ?&gt;&gt; iterable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 覆盖迭代器</span></span><br><span class="line">        iterable = <span class="keyword">new</span> TracingIterable(iterable, tracer());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(suppress = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">wrap</span>(@<span class="title">Advice</span>.<span class="title">Return</span>(<span class="title">readOnly</span> </span>= <span class="keyword">false</span>) List&lt;ConsumerRecord&lt;?, ?&gt;&gt; iterable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 覆盖List</span></span><br><span class="line">        iterable = <span class="keyword">new</span> TracingList(iterable, tracer());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorAdvice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Advice</span>.OnMethodExit(suppress = Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">static</span> <span class="title">void</span> <span class="title">wrap</span>(</span></span><br><span class="line"><span class="class">        @<span class="title">Advice</span>.<span class="title">Return</span>(<span class="title">readOnly</span> </span>= <span class="keyword">false</span>) Iterator&lt;ConsumerRecord&lt;?, ?&gt;&gt; iterator) &#123;</span><br><span class="line">      <span class="keyword">if</span> (iterator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 覆盖迭代器</span></span><br><span class="line">        iterator = <span class="keyword">new</span> TracingIterator(iterator, tracer());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TracingIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">ConsumerRecord</span>&lt;?, ?&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ConsumerRecord&lt;?, ?&gt;&gt; delegateIterator;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumerTracer tracer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Note: this may potentially create problems if this iterator is used from different threads. But</span></span><br><span class="line"><span class="comment">   * at the moment we cannot do much about this.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> Context currentContext;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> Scope currentScope;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TracingIterator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Iterator&lt;ConsumerRecord&lt;?, ?&gt;&gt; delegateIterator, KafkaConsumerTracer tracer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.delegateIterator = delegateIterator;</span><br><span class="line">    <span class="keyword">this</span>.tracer = tracer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    closeScopeAndEndSpan();</span><br><span class="line">    <span class="keyword">return</span> delegateIterator.hasNext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> ConsumerRecord&lt;?, ?&gt; next() &#123;</span><br><span class="line">    <span class="comment">// in case they didn't call hasNext()...</span></span><br><span class="line">    <span class="comment">// 清除上一条消息的上下文</span></span><br><span class="line">    closeScopeAndEndSpan();</span><br><span class="line"></span><br><span class="line">    ConsumerRecord&lt;?, ?&gt; next = delegateIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 生成上下文，包含span，如果消息有上下文则提取</span></span><br><span class="line">      currentContext = tracer.startSpan(next);</span><br><span class="line">      currentScope = currentContext.makeCurrent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeScopeAndEndSpan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentScope != <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentScope.close();</span><br><span class="line">      currentScope = <span class="keyword">null</span>;</span><br><span class="line">      tracer.end(currentContext);</span><br><span class="line">      currentContext = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    delegateIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从上述源码可以看到：-1"><a href="#从上述源码可以看到：-1" class="headerlink" title="从上述源码可以看到："></a>从上述源码可以看到：</h4><ol><li>迭代器每获取下一个元素，会先清除上下文，然后再生成新的上下文，如果消息头有上下文信息则提取</li><li>每次判断 hasNext 是都会清除上下文，所以遍历时循环结束，上下文也会被清除</li></ol><h4 id="Consumer-traceId-消息缺失分析"><a href="#Consumer-traceId-消息缺失分析" class="headerlink" title="Consumer traceId 消息缺失分析"></a>Consumer traceId 消息缺失分析</h4><ol><li>同上在消费消息时，会使用 foreach，如果逻辑不在 foreach 之间，则会造成 traceId 缺失。</li><li>有的是使用线程池，同样会造成 traceId 缺失</li></ol><br/><h3 id="Opentelemetry-日志上下文"><a href="#Opentelemetry-日志上下文" class="headerlink" title="Opentelemetry 日志上下文"></a>Opentelemetry 日志上下文</h3><p>同样是先看看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenTelemetryContextDataProvider</span> <span class="keyword">implements</span> <span class="title">ContextDataProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns context from the current span when available.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A map containing string versions of the traceId, spanId, and traceFlags, which can then</span></span><br><span class="line"><span class="comment">   *     be accessed from layout components</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">supplyContextData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Span currentSpan = Span.current();</span><br><span class="line">    <span class="keyword">if</span> (!currentSpan.getSpanContext().isValid()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; contextData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    SpanContext spanContext = currentSpan.getSpanContext();</span><br><span class="line">    contextData.put(TRACE_ID, spanContext.getTraceId());</span><br><span class="line">    contextData.put(SPAN_ID, spanContext.getSpanId());</span><br><span class="line">    contextData.put(TRACE_FLAGS, spanContext.getTraceFlags().asHex());</span><br><span class="line">    <span class="keyword">return</span> contextData;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，不是使用的 MDC，另外可以尝试使用下面方式使用自定义的上下文数据存储（亲测不行，这个可以通过修改源码解决）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:path/to/opentelemetry-javaagent.jar -Dio.opentelemetry.context.contextStorageProvider=your.package.CustomContextStorageProvider -jar your-application.jar</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;背景：项目中有一些消费 kafka 消息者打印的日志中缺失 traceId，项目中使用的是 javaagent 的方式接入 opentelemetry，使用的版本是 1.4.x。 &lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Ka</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Antlr4 初探</title>
    <link href="http://example.com/2024/07/28/Antlr4-%E5%88%9D%E6%8E%A2/"/>
    <id>http://example.com/2024/07/28/Antlr4-%E5%88%9D%E6%8E%A2/</id>
    <published>2024-07-28T08:59:57.000Z</published>
    <updated>2024-07-28T09:47:06.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看 Shardingjdbc 源码，其中 Sql 使用的语法解析器是 Antlr4，经过了解许多框架都使用 Antlr4 作为语法解析器。</p></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Antlr 全称（ANother Tool for Language Recognition），是一款强大的语法分析器生成工具，像推特、Hadoop、Oracle 等知名公司都在使用它来构建自己的语言处理类项目。</p><p>一门语言的正式描述称为语法，Antlr 可以为语言生成词法分析器，并自动建立语法分析树和树的遍历器，然后我们就能访问树的节点，执行自定义业务逻辑代码。</p><p>在实际使用 Antlr 时，我们不需要关心词法分析和语法分析的过程，只需定义语法规则以及处理最后的语法分析树即可。例如，可以通过环境配置（如使用 Idea 插件）、引入相关依赖（如在 Pom 文件中添加 Antlr 依赖）、编写自定义业务逻辑等步骤来实现基于 Antlr 的应用。</p><br/><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="词法分析器-Lexer"><a href="#词法分析器-Lexer" class="headerlink" title="词法分析器 (Lexer)"></a>词法分析器 (Lexer)</h4><ul><li>词法分析是指在计算机科学中，将字符序列转换为单词（Token）的过程，简单理解就是分词的过程。</li><li>所谓 Token ，就是源文件中不可再进一步分割的一串字符，类似于英语中单词，或汉语中的词。</li><li>==词法分析器 (Lexer) 就是根据规则将文本（字符流）转换为单词（Token）的程序。==<img src="https://s21.ax1x.com/2024/07/28/pkq4R4x.png" alt="截图" /></li></ul><h4 id="语法解析器-Parser"><a href="#语法解析器-Parser" class="headerlink" title="语法解析器 (Parser)"></a>语法解析器 (Parser)</h4><ul><li>词法分析完成后，字符流就被转换为 Token 流了，接下来根据语言的语法规则来解析这个 Token 流，被称为语法解析。</li><li>语法解析器通常作为编译器或解释器出现。==它的作用是进行语法检查，并将词法分析器（Lexer）输出的 Token 流解析成一个抽象语法树。==<img src="https://s21.ax1x.com/2024/07/28/pkq4fC6.png" alt="截图" /></li></ul><h4 id="抽象语法树-Abstract-Syntax-Tree-AST"><a href="#抽象语法树-Abstract-Syntax-Tree-AST" class="headerlink" title="抽象语法树 (Abstract Syntax Tree,AST)"></a>抽象语法树 (Abstract Syntax Tree,AST)</h4><p>抽象语法树是源代码结构的一种抽象表示，它以树的形状表示语言的语法结构。抽象语法树一般可以用来进行代码语法的检查，代码风格的检查，代码的格式化，代码的高亮，代码的错误提示以及代码的自动补全等等。</p><br/><h3 id="Antlr-Grammar文件简介"><a href="#Antlr-Grammar文件简介" class="headerlink" title="Antlr  Grammar文件简介"></a>Antlr  Grammar文件简介</h3><p>下面是一个简单的 Grammar 文件 Expr.g4，定义了一个简单的四则运算语法规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">prog:    expr EOF ;</span><br><span class="line">expr:    expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr  #MultiOrDiv</span><br><span class="line">    |    expr (&#39;+&#39;|&#39;-&#39;) expr  #AddOrSub</span><br><span class="line">    |    INT     #Lieteral</span><br><span class="line">    |    &#39;(&#39; expr &#39;)&#39;   #Single</span><br><span class="line">    ;</span><br><span class="line">NEWLINE : [\r\n]+ -&gt; skip;</span><br><span class="line">INT     : [0-9]+ ;</span><br></pre></td></tr></table></figure><ul><li>grammar Expr: 声明一个名为 Expr 的语法规则</li><li>Grammar 文件中以小写字母开头的为语法规则，以大写字母开头的为词法规则，那么本规则中语法规则有 prog、expr，词法规则有 NEWLINE、INT</li><li>prog: 定义了一个语法规则，定义了一个 expr 表达式，后面跟着 EOF 标识文件结束</li><li>expr: 定义了一个递归语法规则，标识可以匹配 n+n、n*n、n-n、n/n、(n) 这样的四则运算，其中 n 必须是 INT，规则 prog 引用的表达式 expr 就是本规则。</li><li>NEWLINE: 定义了一个词法规则，表示条规一个或多个回车或换行符。</li><li>INT: 定义了一个词法规则，表示一个或多个 0-9 的数字</li></ul><br/><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><h4 id="安装-Antlr"><a href="#安装-Antlr" class="headerlink" title="安装 Antlr"></a>安装 Antlr</h4><p>安装 Anltr 的方式有很多种，可以安装系统命令行工具，也可以是 ide 插件，本文安装的是 idea 插件。其他方式可以参考 <a href="https://github.com/antlr/antlr4/blob/master/doc/getting-started.md" target="_blank" rel="noopener">传送门</a>。</p><img src="https://s21.ax1x.com/2024/07/28/pkq45vD.png" alt="截图" style="zoom:50%;" /><br><br><img src="https://s21.ax1x.com/2024/07/28/pkq4TDH.png" alt="截图" />配置也很简单，我这主要配了根据规则生成的代码路径、已经生成的代码语言。<h4 id="编写-Grammer-文件"><a href="#编写-Grammer-文件" class="headerlink" title="编写 Grammer 文件"></a>编写 Grammer 文件</h4><p>这里直接使用上述讲解中使用的语法文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grammar Expr;</span><br><span class="line">package org.apache.shardingsphere.example.parser.demo;</span><br><span class="line">prog:    expr EOF ;</span><br><span class="line">expr:    expr (&#39;*&#39;|&#39;&#x2F;&#39;) expr  #MultiOrDiv</span><br><span class="line">    |    expr (&#39;+&#39;|&#39;-&#39;) expr  #AddOrSub</span><br><span class="line">    |    INT     #Lieteral</span><br><span class="line">    |    &#39;(&#39; expr &#39;)&#39;   #Single</span><br><span class="line">    ;</span><br><span class="line">NEWLINE : [\r\n]+ -&gt; skip;</span><br><span class="line">INT     : [0-9]+ ;</span><br></pre></td></tr></table></figure><h4 id="使用插件解析语法树"><a href="#使用插件解析语法树" class="headerlink" title="使用插件解析语法树"></a>使用插件解析语法树</h4><img src="https://s21.ax1x.com/2024/07/28/pkq4bVA.png" alt="截图" style="zoom:50%;" /><br><br><img src="https://s21.ax1x.com/2024/07/28/pkq59bj.png" alt="截图" /><h4 id="根据-Grammer-文件生成代码"><a href="#根据-Grammer-文件生成代码" class="headerlink" title="根据 Grammer 文件生成代码"></a>根据 Grammer 文件生成代码</h4><img src="https://s21.ax1x.com/2024/07/28/pkq5PVs.png" alt="截图" style="zoom:50%;" /><br><br><img src="https://s21.ax1x.com/2024/07/28/pkq5ian.png" alt="截图" style="zoom:80%;" /><p>其中文件的含义：</p><ul><li>ExprParser: 包含语法分析器的定义，专门用来识别我们的语言。</li><li>ExprLexer: 词法分析器的定义，将输入字符分解为词汇符号；</li><li>ExprLexer.tokens: antlr4 会将我们定义的词法符号指定一个数字类型，然后将对应的关系存储在这个文件中。</li><li>ExprListener: antlr4 在遍历语法树的时候，遍历器会触发一系列的事件，通知我们的监听器；ExprListener 是监听器的接口定义  ExprBaseListener 是监听器的空实现。</li><li>ExprVisitor: 如果我们想要自己显示的自定义遍历语法树，可以使用 Visitor 来遍历树，ExprBaseVistor 是默认的空实现。</li></ul><p>==生成代码后，还需要引入对应的依赖==</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.antlr<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>antlr4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExprDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建字符流</span></span><br><span class="line">        CodePointCharStream charStream = CharStreams.fromString(<span class="string">"1+2+3*4"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从字符流分析词法， 解析为token</span></span><br><span class="line">        ExprLexer lexer = <span class="keyword">new</span> ExprLexer(charStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从token进行分析</span></span><br><span class="line">        ExprParser parser = <span class="keyword">new</span> ExprParser(<span class="keyword">new</span> CommonTokenStream( lexer) );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用监听器，遍历语法树，根据语法定义，prog为语法树的根节点</span></span><br><span class="line">        ExprParser.ProgContext prog = parser.prog();</span><br><span class="line">        ParseTreeWalker walker = <span class="keyword">new</span> ParseTreeWalker();</span><br><span class="line">        walker.walk( <span class="keyword">new</span> ExprBaseListener(), prog );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用visitor，生成自定义的对象</span></span><br><span class="line">        Object accept = prog.accept(<span class="keyword">new</span> ExprBaseVisitor&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        System.out.println(accept);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印生成的语法树</span></span><br><span class="line">        System.out.println( prog.toStringTree(parser));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义-Visitor"><a href="#自定义-Visitor" class="headerlink" title="自定义 Visitor"></a>自定义 Visitor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvalExprVisitor</span> <span class="keyword">extends</span> <span class="title">ExprBaseVisitor</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitProg</span><span class="params">(ExprParser.ProgContext ctx)</span> </span>&#123;</span><br><span class="line">        ExprParser.ExprContext expr = ctx.expr();</span><br><span class="line">        <span class="keyword">return</span> visit(expr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitAddOrSub</span><span class="params">(ExprParser.AddOrSubContext ctx)</span> </span>&#123;</span><br><span class="line">        Integer expr1 = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        Integer expr2 = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"+"</span>.equals(ctx.getChild(<span class="number">1</span>).getText())) &#123;</span><br><span class="line">            <span class="keyword">return</span> expr1 + expr2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> expr1 - expr2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitSingle</span><span class="params">(ExprParser.SingleContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> visit(ctx.expr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitLieteral</span><span class="params">(ExprParser.LieteralContext ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(ctx.INT().getText());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">visitMultiOrDiv</span><span class="params">(ExprParser.MultiOrDivContext ctx)</span> </span>&#123;</span><br><span class="line">        Integer expr1 = visit(ctx.expr(<span class="number">0</span>));</span><br><span class="line">        Integer expr2 = visit(ctx.expr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"*"</span>.equals(ctx.getChild(<span class="number">1</span>).getText())) &#123;</span><br><span class="line">            <span class="keyword">return</span> expr1 * expr2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> expr1 / expr2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExprDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; testSet = Arrays.asList(</span><br><span class="line">                <span class="string">"1+2"</span>,</span><br><span class="line">                <span class="string">"1+2+3*4"</span>,</span><br><span class="line">                <span class="string">"3/3"</span>,</span><br><span class="line">                <span class="string">"10/2"</span>,</span><br><span class="line">                <span class="string">"5*5+10+5*5"</span>,</span><br><span class="line">                <span class="string">"6+5*(1+2)"</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; res = Arrays.asList(</span><br><span class="line">                <span class="number">3</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">60</span>, <span class="number">21</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testSet.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 构建字符流</span></span><br><span class="line">            CodePointCharStream charStream = CharStreams.fromString(testSet.get(i));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从字符流分析词法， 解析为token</span></span><br><span class="line">            ExprLexer lexer = <span class="keyword">new</span> ExprLexer(charStream);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从token进行分析</span></span><br><span class="line">            ExprParser parser = <span class="keyword">new</span> ExprParser(<span class="keyword">new</span> CommonTokenStream(lexer));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用监听器，遍历语法树，根据语法定义，prog为语法树的根节点</span></span><br><span class="line">            ExprParser.ProgContext prog = parser.prog();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用visitor，生成自定义的对象</span></span><br><span class="line">            Integer integer = prog.accept(<span class="keyword">new</span> EvalExprVisitor());</span><br><span class="line">            System.out.println(integer);</span><br><span class="line">            Assert.assertEquals(integer, res.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，上述的内容已经足以满足我研究 Shardingjdbc 的 Sql 语法解析了，如果对 Listener 感兴趣的可以参考 <a href="https://github.com/antlr/antlr4/blob/master/doc/listeners.md" target="_blank" rel="noopener">传送门</a></p><blockquote><p>参考</p><p><a href="https://github.com/antlr/antlr4/blob/master/doc/index.md" target="_blank" rel="noopener">https://github.com/antlr/antlr4/blob/master/doc/index.md</a></p><p><a href="https://iamazy.github.io/2020/02/12/antlr4-jiao-cheng/" target="_blank" rel="noopener">https://iamazy.github.io/2020/02/12/antlr4-jiao-cheng/</a></p><p><a href="https://juejin.cn/post/7174054658460090381?searchId=20240727211235DCC7CEBC417B312D14AF" target="_blank" rel="noopener">https://juejin.cn/post/7174054658460090381?searchId=20240727211235DCC7CEBC417B312D14AF</a></p><p>注：本文中的例子引用自 </p><p><a href="https://juejin.cn/post/7174054658460090381?searchId=20240727211235DCC7CEBC417B312D14AF" target="_blank" rel="noopener">https://juejin.cn/post/7174054658460090381?searchId=20240727211235DCC7CEBC417B312D14AF</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在看 Shardingjdbc 源码，其中 Sql 使用的语法解析器是 Antlr4，经过了解许多框架都使用 Antlr4 作为语法解析器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>shardingjdbc 数据分片笔记</title>
    <link href="http://example.com/2024/06/29/shardingjdbc-%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/06/29/shardingjdbc-%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87%E7%AC%94%E8%AE%B0/</id>
    <published>2024-06-29T13:12:00.000Z</published>
    <updated>2024-06-29T13:34:31.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分片路由引擎"><a href="#分片路由引擎" class="headerlink" title="分片路由引擎"></a>分片路由引擎</h3><p>org.apache.shardingsphere.core.route.type.RoutingEngine</p><p><img src="https://s21.ax1x.com/2024/06/29/pkcknFP.png" /> <br></p><p><img src="https://s21.ax1x.com/2024/06/29/pkckKW8.png" /> <br></p><img src="https://s21.ax1x.com/2024/06/29/pkcAPkq.md.png" />具体选择什么分片路由引擎取决于执行的 sql<p>org.apache.shardingsphere.core.route.router.sharding.ShardingRouter#route</p><h3 id="分片路由策略"><a href="#分片路由策略" class="headerlink" title="分片路由策略"></a>分片路由策略</h3><p>org.apache.shardingsphere.core.strategy.route.ShardingStrategy</p><img src="https://s21.ax1x.com/2024/06/29/pkcklQg.png" /><ul><li><p>org.apache.shardingsphere.core.strategy.route.none.NoneShardingStrategy  不进行分片路由</p></li><li><p>org.apache.shardingsphere.core.strategy.route.none.NoneShardingStrategy 根据行表达式路由，不支持按条件范围分片</p></li><li><p>org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy 经典分片策略，内置按值分片算法，按范围分配算法</p><img src="https://s21.ax1x.com/2024/06/29/pkck1yQ.png" /></li><li><p>org.apache.shardingsphere.core.strategy.route.complex.ComplexShardingStrategy 组合条件分片策略，逻辑需要执行实现，==同时如果某些逻辑 StandardShardingStrategy 无法实现也可以考虑使用 ComplexShardingStrategy==。</p></li><li><p>org.apache.shardingsphere.core.strategy.route.hint.HintShardingStrategy 强制分片策略，适合需要按照分数据库的列进行分片的场景，比如根据 来源ip 进行分片，底层基于 ThreadLocal 实现，需要在执行 sql 前指定分片值。</p></li></ul><h3 id="使用-DEMO"><a href="#使用-DEMO" class="headerlink" title="使用 DEMO"></a>使用 DEMO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.apache.shardingsphere.example.sharding.raw.jdbc.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.config.sharding.KeyGeneratorConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.config.sharding.ShardingRuleConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.config.sharding.TableRuleConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.config.sharding.strategy.ComplexShardingStrategyConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.api.sharding.complex.ComplexKeysShardingValue;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.core.constant.properties.ShardingPropertiesConstant;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.example.algorithm.PreciseModuloShardingTableAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.example.config.ExampleConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.example.core.api.DataSourceUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.shardingsphere.shardingjdbc.api.ShardingDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingMultiDatabasesAndTablesConfigurationPrecise</span> <span class="keyword">implements</span> <span class="title">ExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ShardingRuleConfiguration shardingRuleConfig = <span class="keyword">new</span> ShardingRuleConfiguration();</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(getOrderTableRuleConfiguration());</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(getOrderItemTableRuleConfiguration());</span><br><span class="line">        shardingRuleConfig.getBindingTableGroups().add(<span class="string">"t_order, t_order_item"</span>);</span><br><span class="line">        shardingRuleConfig.getBroadcastTables().add(<span class="string">"t_address"</span>);</span><br><span class="line"><span class="comment">//        shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(new InlineShardingStrategyConfiguration("user_id", "demo_ds_$&#123;user_id % 2&#125;"));</span></span><br><span class="line">        shardingRuleConfig.setDefaultDatabaseShardingStrategyConfig(<span class="keyword">new</span> ComplexShardingStrategyConfiguration(<span class="string">"user_id"</span>, <span class="keyword">new</span> CustomComplexKeysShardingAlgorithm()));</span><br><span class="line">        shardingRuleConfig.setDefaultTableShardingStrategyConfig(<span class="keyword">new</span> StandardShardingStrategyConfiguration(<span class="string">"order_id"</span>, <span class="keyword">new</span> PreciseModuloShardingTableAlgorithm()));</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ShardingPropertiesConstant.SQL_SHOW.getKey(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ShardingDataSourceFactory.createDataSource(createDataSourceMap(), shardingRuleConfig, props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TableRuleConfiguration <span class="title">getOrderTableRuleConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TableRuleConfiguration result = <span class="keyword">new</span> TableRuleConfiguration(<span class="string">"t_order"</span>, <span class="string">"demo_ds_$&#123;0..1&#125;.t_order_$&#123;[0, 1]&#125;"</span>);</span><br><span class="line">        result.setKeyGeneratorConfig(<span class="keyword">new</span> KeyGeneratorConfiguration(<span class="string">"SNOWFLAKE"</span>, <span class="string">"order_id"</span>, getProperties()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TableRuleConfiguration <span class="title">getOrderItemTableRuleConfiguration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TableRuleConfiguration result = <span class="keyword">new</span> TableRuleConfiguration(<span class="string">"t_order_item"</span>, <span class="string">"demo_ds_$&#123;0..1&#125;.t_order_item_$&#123;[0, 1]&#125;"</span>);</span><br><span class="line">        result.setKeyGeneratorConfig(<span class="keyword">new</span> KeyGeneratorConfiguration(<span class="string">"SNOWFLAKE"</span>, <span class="string">"order_item_id"</span>, getProperties()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, DataSource&gt; <span class="title">createDataSourceMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, DataSource&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">"demo_ds_0"</span>, DataSourceUtil.createDataSource(<span class="string">"demo_ds_0"</span>));</span><br><span class="line">        result.put(<span class="string">"demo_ds_1"</span>, DataSourceUtil.createDataSource(<span class="string">"demo_ds_1"</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line">        result.setProperty(<span class="string">"worker.id"</span>, <span class="string">"123"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomComplexKeysShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">ComplexKeysShardingAlgorithm</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, ComplexKeysShardingValue&lt;Integer&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">            List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            shardingValue.getColumnNameAndShardingValuesMap().forEach((column, valueList) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(column, <span class="string">"user_id"</span>)) &#123;</span><br><span class="line">                    valueList.forEach(value -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                            result.addAll(availableTargetNames);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Optional&lt;String&gt; optional = availableTargetNames.stream().filter(name -&gt; name.endsWith(String.valueOf(value % <span class="number">2</span>))).findFirst();</span><br><span class="line">                            optional.ifPresent(result::add);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>==如果 sql 语句没有命中分片条件，将在所有的物理表中执行 sql==</li><li>hint 必须要在执行 sql 前设置条件值，否则会和上述一样因未命中分片条件而在所有物理表执行 sql</li><li>目前支持原生的分片策略，如果要支持自定义的可能得把大部分上游组件给改了</li><li>支持很多 sqi 扩展钩子，例如 org.apache.shardingsphere.sql.parser.hook.SPIParsingHook</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;分片路由引擎&quot;&gt;&lt;a href=&quot;#分片路由引擎&quot; class=&quot;headerlink&quot; title=&quot;分片路由引擎&quot;&gt;&lt;/a&gt;分片路由引擎&lt;/h3&gt;&lt;p&gt;org.apache.shardingsphere.core.route.type.RoutingEngin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>记录一次增量数据一致性问题</title>
    <link href="http://example.com/2023/11/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2023/11/19/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E5%A2%9E%E9%87%8F%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</id>
    <published>2023-11-19T02:11:45.000Z</published>
    <updated>2023-11-19T15:11:48.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近收到客户投诉出现数据无法操作的问题，经过排查，Mysql 和 ES 数据出现一致性问题。我们的使用场景是定于 Mysql binlog 投递到 Kafka，增量服务顺序消费 Kafka 中的消息，更新 ES 中的文档。</p></blockquote><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>在分析问题前先简单看下索引结构，这里只看出现问题的字段，主要就是用于存储标签 id 的一个 long 类型的字段，存的是一个数组。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span> : &#123;</span><br><span class="line">    <span class="attr">"f_tag_id"</span> : &#123;</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"long"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"f_status"</span> : &#123;</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"byte"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>先简单看一下标签增量的逻辑，由于标签存的是一个数组，所以在更新的时候是先把文档查询出来，再对相应的数组字段做元素的新增或者删除，然后再重新索引到 ES 中。</li><li>生产中的场景是同时有两个 binlog 并发，但是是分两次消费（同一批次的消息我们这边会在内存进行组装），A 表的 binlog 先更新 f_status，B 表 (标签关联表) 的 binlog 先将文档查询出来，更新完之后再将整个文档索引回 ES（更新代码通用性，所以是更新整个文档）。</li><li>由于 ES 索引更新刷盘并非实时的，导致 B 表查询出来的文档是旧的，所以 B 表在更新索引时将旧的数据覆盖了新的数据。</li><li>举一个简单的例子：<ul><li>假设原本 f_status = 0, f_tag_id = []</li><li>A 表更新 f_status =1，此时 f_status = 1, f_tag_id = []</li><li>B 表更新 f_tag_id = [1]，由于 ES 刷盘存在延迟，导致更新的数据为 f_status = 0, f_tag_id = [1]</li></ul></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>最初的想法是只更新 f_tag_id 字段，但是这样其实还是会有问题，举个例子 B 表 (标签关联表) 针对同一条记录两个标签关联数据，意味着会有两个 binlog 生成，假设很不巧，Kafka 消费者分了两个批次去更新索引，就会造成和上述类似的场景。</p><ul><li>假设原本 f_tag_id = [1,2]</li><li>第一条 binlog 更新 f_tag_id = [1,2,3]</li><li>第二条 binlog 消费时，先查询 f_tag_id = [1,2]，此时在去更新 f_tag_id 就会变成 [1,2,4]，还是会出现数据不一致问题</li></ul></li><li><p>第一个方案行不通，那能不能让 f_tag_id 像更新其他字段一样，不需要先查询出来组装再重新索引回 ES，答案是可以，那就是利用 ES 脚本更新，因为更新操作是可以直接更新内存的数据，所以数据是实时的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>: &#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">      List tagIdList = ctx._source.f_tag_id == null </span></span><br><span class="line"><span class="string">          ? new ArrayList() </span></span><br><span class="line"><span class="string">          : ctx._source.f_tag_id;</span></span><br><span class="line"><span class="string">      if("</span>insert<span class="string">".equals(params.method) </span></span><br><span class="line"><span class="string">        &amp;&amp; !tagIdList.contains(params.changeTagId))&#123;</span></span><br><span class="line"><span class="string">        tagIdList.add(params.changeTagId);</span></span><br><span class="line"><span class="string">      &#125; else if("</span>delete<span class="string">".equals(params.method)</span></span><br><span class="line"><span class="string">        &amp;&amp; tagIdList.contains(params.changeTagId))&#123;</span></span><br><span class="line"><span class="string">         tagIdList.remove(tagIdList.indexOf(params.changeTagId));</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      ctx._source.f_tag_id = tagIdList;</span></span><br><span class="line"><span class="string">    "</span><span class="string">""</span>,</span><br><span class="line">    <span class="attr">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">    <span class="attr">"params"</span>: &#123;</span><br><span class="line">      <span class="attr">"changeTagId"</span>: <span class="number">12</span>,</span><br><span class="line">      <span class="attr">"method"</span>: <span class="string">"insert"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">    <span class="attr">"f_tag_id"</span>: [<span class="number">12</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大概思路就是利用脚本直接针对 f_tag_id 进行元素变更，这样就不用担心查出来的 f_tad_id 是旧的了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.14/docs-update.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/7.14/docs-update.html</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/painless/7.14/painless-types.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/painless/7.14/painless-types.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近收到客户投诉出现数据无法操作的问题，经过排查，Mysql 和 ES 数据出现一致性问题。我们的使用场景是定于 Mysql binlog 投递到 Kafka，增量服务顺序消费 Kafka 中的消息，更新 ES 中的文档。&lt;/p&gt;
&lt;/blockq</summary>
      
    
    
    
    
    <category term="ES" scheme="http://example.com/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务之 2PC 的 XA 规范实现</title>
    <link href="http://example.com/2023/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B-2PC-%E7%9A%84-XA-%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2023/07/25/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B-2PC-%E7%9A%84-XA-%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0/</id>
    <published>2023-07-25T02:11:00.000Z</published>
    <updated>2023-07-25T02:16:46.841Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚开始学习分布式事务时，第一个解决方案就是 2PC，但是一直没有写过 demo，也没有生产中使用过这种方案，随意是既熟悉又陌生。本文只在实现一个 2PC XA方案的 demo，万一将来需要用到这种方案不至于少也不懂。</p></blockquote><h4 id="2PC-简介"><a href="#2PC-简介" class="headerlink" title="2PC 简介"></a>2PC 简介</h4><p>2PC 主要分为两个阶段，准备阶段、提交阶段。</p><p><strong>准备阶段</strong>：TM（事务管理器）向 RM（资源管理器）发送 Prepare 消息，RM 本地执行事务，此时 RM 并未提交本地事务（上锁），RM 发送执行成功/失败给到 TM</p><p><strong>提交阶段</strong>：TM 向 RM 发送 Commit/Rollback 消息，RM 根据 TM 发送的消息执行提交或回滚本地事务。</p><p>以下是网上找的一张 2PC 的流程图：</p><img src="/images/d168e9ad85a69717fcd5f4296458e76b.png" alt="截图" style="zoom:80%;" /><h4 id="XA-方案"><a href="#XA-方案" class="headerlink" title="XA 方案"></a>XA 方案</h4><blockquote><p>2PC 的传统方案是在数据库层面实现的，如 Oracle、MySQL 都支持 2PC 协议，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准，国际开放标准组织 Open Group 定义了分布式事务处理模型DTP（Distributed Transaction Processing Reference Model）。</p></blockquote><p><strong>DTP 模型定义如下角色：</strong></p><ul><li>AP（Application Program）：即应用程序，可以理解为使用 DTP 分布式事务的程序。</li><li>RM（Resource Manager）：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。</li><li>TM（Transaction Manager）：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个 RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</li><li>DTP 模型定义TM和RM之间通讯的接口规范叫 XA，简单理解为数据库提供的 2PC 接口协议，基于数据库的 XA 协议来实现 2PC 又称为 XA 方案</li></ul><p><strong>XA 执行流程：（作者比较懒，什么都没留下）</strong></p><blockquote><p>流程可以参看大佬的博客：<a href="https://zhuanlan.zhihu.com/p/263555694" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/263555694</a></p></blockquote><p><strong>具体实现：</strong></p><blockquote><p> Java事务API（JTA：Java Transaction API）和它的同胞Java事务服务（JTS：Java Transaction Service），为J2EE平台提供了分布式事务服务（distributed transaction）的能力。 某种程度上，可以认为JTA规范是XA规范的Java版，其把XA规范中规定的DTP模型交互接口抽象成Java接口中的方法，并规定每个方法要实现什么样的功能。</p></blockquote><p>下面的例子基于 Atomikos TransactionEssentials 实现 JTA： </p><p>所需要依赖，这里用的 Gradle，用的 Maven 家人们可以自行找下依赖</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">implementation platform(<span class="string">'org.springframework.boot:spring-boot-dependencies:2.7.5'</span>)</span><br><span class="line">implementation <span class="string">'com.atomikos:transactions-jdbc:6.0.0'</span></span><br><span class="line">implementation <span class="string">'com.atomikos:transactions-jta:6.0.0'</span></span><br><span class="line">implementation <span class="string">'javax.transaction:jta:1.1'</span></span><br><span class="line">implementation <span class="string">'com.alibaba:druid:1.2.18'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-web'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-test'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot-starter-test'</span></span><br><span class="line">implementation <span class="string">'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.2.1'</span></span><br><span class="line">implementation <span class="string">'org.springframework.boot:spring-boot'</span></span><br><span class="line">implementation <span class="string">'org.springframework:spring-tx'</span></span><br><span class="line">implementation <span class="string">'mysql:mysql-connector-java:8.0.33'</span></span><br></pre></td></tr></table></figure><p>数据库配置，这里我在本地中启动了两个 Mysql 实例，数据库只要能支持 XA 协议即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里用的Druid，其他连接池只要实现了javax.sql.XADataSource即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> DruidXADataSource <span class="title">createDruidXADataSource</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">        DruidXADataSource druidXADataSource = <span class="keyword">new</span> DruidXADataSource();</span><br><span class="line">        <span class="comment">//&lt;a href="https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E5%88%97%E8%A1%A8"/&gt;</span></span><br><span class="line">        druidXADataSource.setUrl(url);</span><br><span class="line">        druidXADataSource.setUsername(username);</span><br><span class="line">        druidXADataSource.setPassword(password);</span><br><span class="line">        druidXADataSource.setMaxActive(<span class="number">5</span>);</span><br><span class="line">        druidXADataSource.setInitialSize(<span class="number">1</span>);</span><br><span class="line">        druidXADataSource.setMaxWait(<span class="number">15000</span>);</span><br><span class="line">        druidXADataSource.setMinIdle(<span class="number">1</span>);</span><br><span class="line">        druidXADataSource.setTestOnBorrow(<span class="keyword">false</span>);</span><br><span class="line">        druidXADataSource.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        druidXADataSource.setValidationQuery(<span class="string">"select 1"</span>);</span><br><span class="line">        druidXADataSource.setTimeBetweenEvictionRunsMillis(<span class="number">60000</span>);</span><br><span class="line">        druidXADataSource.setMinEvictableIdleTimeMillis(<span class="number">300000</span>);</span><br><span class="line">        druidXADataSource.setAsyncInit(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> druidXADataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是3306端口的实例配置</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.jl.demo.spring.repository.mapper.db3306"</span>, sqlSessionFactoryRef = <span class="string">"sqlSessionFactory3306"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig3306</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource3306</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AtomikosDataSourceBean datasource = <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">        DruidXADataSource druidXADataSource = createDruidXADataSource(<span class="string">"jdbc:mysql://localhost:3306/xa_test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        datasource.setXaDataSource(druidXADataSource);</span><br><span class="line">        <span class="comment">//atomikos要求为每个AtomikosDataSourceBean名称</span></span><br><span class="line">        datasource.setUniqueResourceName(<span class="string">"local_3306"</span>);</span><br><span class="line">        <span class="keyword">return</span> datasource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory3306</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource3306());</span><br><span class="line">        PathMatchingResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(<span class="string">"classpath:/mybatis/db3306/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是3308端口的实例配置</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan</span>(value = <span class="string">"com.jl.demo.spring.repository.mapper.db3308"</span>, sqlSessionFactoryRef = <span class="string">"sqlSessionFactory3308"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceConfig3308</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource3308</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AtomikosDataSourceBean datasource = <span class="keyword">new</span> AtomikosDataSourceBean();</span><br><span class="line">        DruidXADataSource druidXADataSource = createDruidXADataSource(<span class="string">"jdbc:mysql://localhost:3308/xa_test"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        datasource.setXaDataSource(druidXADataSource);</span><br><span class="line">        datasource.setUniqueResourceName(<span class="string">"local_3308"</span>);</span><br><span class="line">        <span class="keyword">return</span> datasource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory3308</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource3308());</span><br><span class="line">        PathMatchingResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(resolver.getResources(<span class="string">"classpath:/mybatis/db3308/*.xml"</span>));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务相关配置，spring 已经帮我们把 JtaTransactionManager 封装好了，底层使用的是我们传入的事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置atomikos事务管理器 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserTransactionManager <span class="title">userTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserTransactionManager userTransactionManager = <span class="keyword">new</span> UserTransactionManager();</span><br><span class="line">        userTransactionManager.setForceShutdown(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> userTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置jta事务管理器，底层使用atomikos事务管理器 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransactionManager <span class="title">jtaTransactionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        JtaTransactionManager jtaTransactionManager = <span class="keyword">new</span> JtaTransactionManager();</span><br><span class="line">        jtaTransactionManager.setTransactionManager(userTransactionManager());</span><br><span class="line">        <span class="keyword">return</span> jtaTransactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面简单看一下 service 层，由于本例子主要是为了测试 Jta 是否能正确回滚两个数据库实例，所以用了两个相同的表，不含业务属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper3306 userMapper3306;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper3308 userMapper3308;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(transactionManager = <span class="string">"jtaTransactionManager"</span>, rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">void</span> <span class="title">insert</span>() </span>&#123;</span><br><span class="line">        User user3306 = <span class="keyword">new</span> User();</span><br><span class="line">        user3306.setName(<span class="string">"111"</span>);</span><br><span class="line">        userMapper3306.insert(user3306);</span><br><span class="line"></span><br><span class="line">        com.jl.demo.spring.repository.model.db3308.User user3308 = <span class="keyword">new</span> com.jl.demo.spring.repository.model.db3308.User();</span><br><span class="line">        user3308.setName(<span class="string">"222"</span>);</span><br><span class="line">        userMapper3308.insert(user3308);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith</span>(SpringExtension<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= AtomikosTestApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">UserServiceImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.insert();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仓库地址：<a href="https://github.com/JerryQTQcjl/distributed-transaction-demo/tree/master/atomikos-xa-demo" target="_blank" rel="noopener">https://github.com/JerryQTQcjl/distributed-transaction-demo/tree/master/atomikos-xa-demo</a></p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction/386" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/distributed_transaction/386</a></p><p><a href="https://github.com/atomikos/transactions-essentials" target="_blank" rel="noopener">https://github.com/atomikos/transactions-essentials</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;刚开始学习分布式事务时，第一个解决方案就是 2PC，但是一直没有写过 demo，也没有生产中使用过这种方案，随意是既熟悉又陌生。本文只在实现一个 2PC XA方案的 demo，万一将来需要用到这种方案不至于少也不懂。&lt;/p&gt;
&lt;/blockquot</summary>
      
    
    
    
    
    <category term="分布式事务" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>聊聊双亲委派机制</title>
    <link href="http://example.com/2023/04/30/%E8%81%8A%E8%81%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2023/04/30/%E8%81%8A%E8%81%8A%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</id>
    <published>2023-04-29T17:17:16.000Z</published>
    <updated>2023-04-29T17:29:38.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近重新看了双亲委派相关的知识，特此记录一下，方便以后重新回顾</p></blockquote><h4 id="Java-类是怎么加载"><a href="#Java-类是怎么加载" class="headerlink" title="Java 类是怎么加载"></a>Java 类是怎么加载</h4><p>Java 通过 ClassLoader 实例的 loadClass 方法将字节码（.class）文件加载到 JVM 的方法区中。啥也不说，先上代码 (～￣▽￣)～：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// 从已加载的类中寻找</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//父委派机制</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//没有父类加载器，则说明父加载器是启动类加载器</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//根据类名从数据源查找对应的字节码，读取二进制流，生成 Class 对象</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                <span class="comment">//官方注释说是链接一个类，这里暂时没用过，下次看看</span></span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处贴的是 ClassLoader 子类 URLClassLoader 的 findClass 方法，也是默认的实现</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = AccessController.doPrivileged(</span><br><span class="line">                <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                        <span class="comment">//根据类名从资源路径查找对应的资源</span></span><br><span class="line">                        String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                        Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//读取二进制流，生成 Class 对象</span></span><br><span class="line">                                <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到 loadClass 主要做了两件事情：</p><ol><li><strong>根据类名从资源路径（文件、网络等）查找对应的字节码资源</strong></li><li><strong>从资源路径读取字节码二进制流，并生成对应的 Class 对象，其中包括权限校验，字节码校验等。</strong></li></ol><h4 id="Java-默认的类加载器"><a href="#Java-默认的类加载器" class="headerlink" title="Java 默认的类加载器"></a>Java 默认的类加载器</h4><p>JDK9 之前默认的类加载器有：<strong>AppClassLoader、ExtClassLoader、BootstrapClassloader</strong></p><ul><li>BootstrapClassLoader: JRE 的 lib 目录下 jar 包中的类（以及由虚拟机参数 -Xbootclasspath 指定的类），注意，他不是定义在 Java 代码中的。</li><li>ExtClassLoader：存放在 JRE 的 lib/ext 目录下 jar 包中的类（以及由系统变量 java.ext.dirs 指定的类）。</li><li>AppClassLoader：负责加载应用程序路径下的类（虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径）</li></ul><p>JDK9 及以后默认的类加载器：<strong>AppClassLoader、PlatformClassLoader、BootstrapClassLoader</strong></p><ul><li>PlatformClassLoader：其实就是之前的 ExtClassLoader，只是将大部分原本由 BootstrapClassLoader 加载的类交由 PlatformClassLoader 加载</li></ul><h4 id="Java-类的加载时机有哪些"><a href="#Java-类的加载时机有哪些" class="headerlink" title="Java 类的加载时机有哪些"></a>Java 类的加载时机有哪些</h4><p>类加载的时机有很多，这里主要列举一些易错场景 (～￣▽￣)～：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTimingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new一个对象实例</span></span><br><span class="line">        <span class="keyword">new</span> A(); <span class="comment">//加载A</span></span><br><span class="line">        <span class="comment">//通过反射实例化一个对象</span></span><br><span class="line">        Class.forName(<span class="string">"com.classloader.demo.char01.A"</span>); <span class="comment">//加载A</span></span><br><span class="line">        <span class="comment">//访问类的静态变量</span></span><br><span class="line">        System.out.println(A.word);   <span class="comment">//加载A</span></span><br><span class="line">        <span class="comment">//访问类的静态方法</span></span><br><span class="line">        A.println(); <span class="comment">//加载A</span></span><br><span class="line">        <span class="comment">//子类初始化会触发父类初始化</span></span><br><span class="line">        System.out.println(B.word1); <span class="comment">//加载A、B</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//以下情况不加载</span></span><br><span class="line">        System.out.println(B.word); <span class="comment">//加载A，不加载B</span></span><br><span class="line">        <span class="comment">//创建数组不加载类</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> A[]&#123;&#125;); <span class="comment">//不加载A</span></span><br><span class="line">        <span class="comment">//访问常量不加载类</span></span><br><span class="line">        System.out.println(A.DEFAULT); <span class="comment">//不加载A</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//易混淆情况，编译器无法确定最终变量的值，所以运行期要去加载</span></span><br><span class="line">        System.out.println(A.DEFAULT1); <span class="comment">//加载A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT = <span class="string">"HELLO WORLD"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> String DEFAULT1 = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String word = <span class="string">"HELLO WORLD"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"A was loader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String word1 = <span class="string">"HELLO WORLD"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"B was loader"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="什么是双亲委派机制"><a href="#什么是双亲委派机制" class="headerlink" title="什么是双亲委派机制"></a>什么是双亲委派机制</h4><p>仔细的同学应该会发现，上面加载类的方法中，优先会调用 <strong>parent.loadClass</strong> 去加载类，如果没加载到才会走继续往下走。</p><p><strong>其实这就是类加载的父委派机制，优先由父加载器去加载类，父类加载器没加载到才有自身尝试去加载。</strong></p><p>那么什么是双亲委派机制呢，还记得上面提到 JDK8 的默认类加载器有 AppClassLoader、ExtClassLoader、BootstrapClassloader，BootstrapClassloader 是 ExtClassLoader 的父加载器，ExtClassLoader 是 AppClassLoader 的父加载器。嗯，就是因为 AppClassLoader 有一个爸爸和一个爷爷，所以称为双亲委派机制。就是这么简单 ︿(￣︶￣)︿。</p><p><strong>那么双亲委派机制的作用是什么呢，我认为有两点：</strong></p><ol><li><strong>防止同一个类被加载到 JVM 多次</strong></li><li><strong>避免 Java 内部的一些基础类没有被正确加载，导致出现难以意料的异常</strong></li></ol><h4 id="JDBC-真的打破双亲委派了吗"><a href="#JDBC-真的打破双亲委派了吗" class="headerlink" title="JDBC 真的打破双亲委派了吗"></a>JDBC 真的打破双亲委派了吗</h4><p>在说 JDBC 是否打破双亲委派之前我们先来聊聊什么是打破双亲委派机制，嗯，就是让类的加载顺序不在是 <strong>BootstrapClassloader -&gt; ExtClassLoader -&gt; AppClassLoader</strong>，就是字面上的意思不再让爷爷和爸爸先加载，而是儿子自己想先加载就先加载 ︿(￣︶￣)︿。那么我们该怎么做呢，是不是<strong>自定义一个类加载器，重写下 loadClass 方法不在调用 parent.loadClass 就可以了</strong>？嗯，是的 o(￣▽￣)ｄ。</p><p>那么我们再来看看 JDBC 真的打破双亲委派了吗。老规矩，线上代码 (～￣▽￣)～：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">AppClassLoaderpublic <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取环境变量中配置的驱动</span></span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//通过SPI机制加载驱动类</span></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">                 */</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        <span class="comment">//这里面会加载驱动类（不初始化），但是会通过反射实例化驱动类（会初始化）</span></span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">        println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">        <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">                <span class="comment">//加载驱动类并初始化</span></span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//拿到线程上下文中的类加载器，这里如果未设置过获取到的是 AppClassLoader</span></span><br><span class="line">      ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">      <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，DriverManager 通过 SPI 机制，加载 Driver 驱动类，而 ServiceLoader 中其实只是拿到当前上下文中的类加载器，那么能说他打破了双亲委派机制吗？我个人觉得是不能的，先不说其他，<strong>在未手动设置线程上下文中的类加载器的情况下，线程上下文类加载器是继承至父线程的，其实也就是 AppClassLoader，那正常情况下他走的就是双亲委派机制 （￣︶￣）↗。就算是将自定义的类加载器放入线程上下文中，那也是由自定义的类加载器通过重写 loadClass 打破双亲委派机制呀，所以我认为 JDBC 自身并未打破了双亲委派机制 &lt;(￣︶￣)&gt;。</strong></p><h4 id="Tomcat-如何打破双亲委派"><a href="#Tomcat-如何打破双亲委派" class="headerlink" title="Tomcat 如何打破双亲委派"></a>Tomcat 如何打破双亲委派</h4><p>那么 Tomcat 打破了吗？嗯，它打破了 ｂ（￣▽￣）ｄ，Tomcat7 及以上自定义了类加载器 ParallelWebappClassLoader 和 WebappClassLoader。嗯，这里注意一下，Tomcat6 以下的类加载器有所不同，不过原理都是一样的（其实是我偷懒，不想把 Tomcat6 源码也看了 (╯▽╰)）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (JreCompat.isGraalAvailable() ? <span class="keyword">this</span> : getClassLoadingLock(name)) &#123;</span><br><span class="line">            </span><br><span class="line">        String resourceName = binaryNameToPath(name, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里获取到 ExtClassLoader</span></span><br><span class="line">        ClassLoader javaseLoader = getJavaseClassLoader();</span><br><span class="line">        <span class="keyword">boolean</span> tryLoadingFromJavaseLoader;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url;</span><br><span class="line">            <span class="keyword">if</span> (securityManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                PrivilegedAction&lt;URL&gt; dp = <span class="keyword">new</span> PrivilegedJavaseGetResource(resourceName);</span><br><span class="line">                url = AccessController.doPrivileged(dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//先ExtClassLoader和BoostrapClassLoader的资源路径中查找字节码资源</span></span><br><span class="line">                url = javaseLoader.getResource(resourceName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果资源存在则走ExtClassLoader和BoostrapClassLoader加载</span></span><br><span class="line">            tryLoadingFromJavaseLoader = (url != <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(t);</span><br><span class="line">            tryLoadingFromJavaseLoader = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tryLoadingFromJavaseLoader) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//如果资源存在则走ExtClassLoader和BoostrapClassLoader加载</span></span><br><span class="line">                clazz = javaseLoader.loadClass(name);</span><br><span class="line">                <span class="comment">//return</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否需要委派给父类加载器，默认是AppClassLoader，或者是Tomcat内部的一些类</span></span><br><span class="line">        <span class="keyword">boolean</span> delegateLoad = delegate || filter(name, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (1) Delegate to our parent if requested</span></span><br><span class="line">        <span class="keyword">if</span> (delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="comment">//return</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从本地目录中查找类并加载</span></span><br><span class="line">            clazz = findClass(name);</span><br><span class="line">            <span class="comment">//return</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3) Delegate to parent unconditionally</span></span><br><span class="line">        <span class="keyword">if</span> (!delegateLoad) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//还是没有找到就委派给父加载器，默认是AppClassLoader</span></span><br><span class="line">                clazz = Class.forName(name, <span class="keyword">false</span>, parent);</span><br><span class="line">                <span class="comment">//return</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看 Tomcat 都改了啥：</p><ol><li>首先尝试通过 ExtClassLoader 加载类，防止 java 相关的一些类被先加载了</li><li>判断是否需要委派给父类加载器，或者是是否是Tomcat内部的一些类，是的话则委派给父类加载器</li><li><strong>从本地目录和扩展路径中查找类并加载，还记的早起我们使用 Tomcat 时，会将多个 war 包放在 webapps 吗，那么如果多个 war 中完全的全路径类名，走默认的双亲委派机制就只有先加载的能加载成功。此处便是 Tomcat 打破双亲委派意义了。</strong></li><li>如果还是没有找到，就委派给父类加载器，走双亲委派机制。</li></ol><p>可以看到，Tomcat 的类加载顺序不再是 <strong>BootstrapClassloader -&gt; ExtClassLoader -&gt; AppClassLoader</strong>，而是在 <strong>AppClassLoader 前先尝试通过 WebappClassLoader 加载本地目录</strong> ｂ（￣▽￣）ｄ。</p><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><p>篇幅有点长了，这个下次一定 ╰(￣▽￣)╭</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>Java 通过 ClassLoader 实例的 loadClass 方法将字节码（.class）文件加载到 JVM 的方法区中。</li><li>JDK9 之前默认的类加载器有：<strong>AppClassLoader、ExtClassLoader、BootstrapClassloader</strong> ,JDK9 及以后默认的类加载器：**AppClassLoader、PlatformClassLoader、BootstrapClassLoader **。</li><li>类加载时机包括：new一个对象实例；反射实例化一个对象；访问类的静态变量、方法；子类初始化会触发父类初始化；方法句柄调用加载方法所在类。</li><li>不加载时机：<strong>访问父类静态变量，不加载子类；创建数组不加载类；访问常量不加载类，但是如果编译是无法确定，运行期还是会加载类。</strong></li><li><strong>JVM 为防止同一个类被加载多次</strong>，引入双亲委派机制，加载类过程中，先由其父类加载器加载，未加载到在自己加载</li><li>JDBC 并未打破双亲委派，而 Tomcat 通过自定义 ClassLoader 打破双亲委派。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近重新看了双亲委派相关的知识，特此记录一下，方便以后重新回顾&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Java-类是怎么加载&quot;&gt;&lt;a href=&quot;#Java-类是怎么加载&quot; class=&quot;headerlink&quot; title=&quot;Java</summary>
      
    
    
    
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Spring @Validated 失效分析</title>
    <link href="http://example.com/2023/04/22/Spring-Validated-%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2023/04/22/Spring-Validated-%E5%A4%B1%E6%95%88%E5%88%86%E6%9E%90/</id>
    <published>2023-04-21T17:41:36.000Z</published>
    <updated>2023-04-22T06:07:27.069Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在落地 DDD，希望对 command 进行参数校验，由于部分流量入口是 MQ，所以希望在应用层是用 @Validated 进行参数校验，结果。。。</p></blockquote><h3 id="Controller-中使用-Validated"><a href="#Controller-中使用-Validated" class="headerlink" title="Controller 中使用 @Validated"></a>Controller 中使用 @Validated</h3><p>@Validated 注解的作用这里就不多做介绍了，具体用法在网上应该有不少。</p><p>在之前使用 MVC 架构编码时，通常是将 @Validated 注解或者 @Valid 配置在 Controller 的方法中，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"common/set"</span>)</span><br><span class="line"><span class="keyword">public</span> Response&lt;?&gt; setCommonSetting(<span class="meta">@RequestBody</span> <span class="meta">@Validated</span> SetCommonSettingReqVO reqVO) &#123;</span><br><span class="line">    <span class="comment">//doSomeThings</span></span><br><span class="line">    <span class="keyword">return</span> Response.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在配置应用层校验时，就想当然的按照类似的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addClueTrack</span><span class="params">(@Validated AddClueTrackCommand command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomeThings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果可想而知，@Validated 注解并不生效。</p><h3 id="Validated-是怎么生效的？"><a href="#Validated-是怎么生效的？" class="headerlink" title="@Validated 是怎么生效的？"></a>@Validated 是怎么生效的？</h3><p>竟然不生效，那么就开始分析原因。</p><p>首先可以很容易想到，竟然能在方法执行前就拦截进行校验，那么大概率是使用<strong>动态代理</strong>。就和 @Transactional 事务注解一样，底层都是基于 AOP 实现动态代理。</p><p>接下来为了印证这个想法，就是需要深入看看 Spring 实现的。通过 IDE 可以很方便看到有哪些地方引用了 @Validated 注解：</p><img src="/images/95f16571e945fb66855e76053273ccd1.png" alt="截图" style="zoom:100%;" /><p>其中一个类名一下就引起了我的注意 <strong>MethodValidationPostProcessor</strong>，熟悉 Spring 的小伙伴应该知道，Spring 中有很多 BeanPostProcessor 用于扩展 Bean，Aop 便是基于此实现动态代理的。点进去一看，果不其然：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryAwareAdvisingPostProcessor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? extends Annotation&gt; validatedAnnotationType = Validated<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建切点</span></span><br><span class="line">        Pointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">this</span>.validatedAnnotationType, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(<span class="keyword">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Advice <span class="title">createMethodValidationAdvice</span><span class="params">(@Nullable Validator validator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建拦截器</span></span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="keyword">null</span> ? <span class="keyword">new</span> MethodValidationInterceptor(validator) : <span class="keyword">new</span> MethodValidationInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationMatchingPointcut</span> <span class="keyword">implements</span> <span class="title">Pointcut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassFilter classFilter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodMatcher methodMatcher;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotationMatchingPointcut</span><span class="params">(Class&lt;? extends Annotation&gt; classAnnotationType, <span class="keyword">boolean</span> checkInherited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//切点只针对类级别</span></span><br><span class="line">        <span class="keyword">this</span>.classFilter = <span class="keyword">new</span> AnnotationClassFilter(classAnnotationType, checkInherited);</span><br><span class="line">        <span class="keyword">this</span>.methodMatcher = MethodMatcher.TRUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodValidationPostProcessor 中创建了一个切点，过滤类上添加了 @Validated 的 Bean，只要满足此条件，就会根据 MethodValidationInterceptor 生成对应的代理类。嗯，和 @Transactional 的实现原理差不多。</p><p>ok，看到这里我就在应用服务实现上添加了 @Validated 注解，那么此时注解生效了吗？哈哈，进度条还没过半呢😂</p><p>理论上类上加上 @Validated 注解，应该会生成动态代理类的，竟然没成功进行参数校验，我能想到的原因有二：</p><p><strong>1. MethodValidationPostProcessor 没注入到 BeanFactory 中，所以没生成对应的代理类</strong><br><strong>2. MethodValidationInterceptor 对还有其他需要满足的条件，而目前还未满足</strong></p><p>这里先剧透一下，答案是 2 🌝</p><h3 id="MethodValidationInterceptor-需要满足什么条件"><a href="#MethodValidationInterceptor-需要满足什么条件" class="headerlink" title="MethodValidationInterceptor 需要满足什么条件"></a>MethodValidationInterceptor 需要满足什么条件</h3><p>竟然答案是2，那这里就先讲一下 MethodValidationInterceptor，MethodValidationPostProcessor 是怎么注册到容器的咱们后面再来讲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">ExecutableValidatorpublic <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Validator validator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Standard Bean Validation 1.1 API</span></span><br><span class="line">        ExecutableValidator execVal = <span class="keyword">this</span>.validator.forExecutables();</span><br><span class="line">        Method methodToValidate = invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取类本身的实例（非代理类），请记住这里，这里就是和 Controller 最大的区别</span></span><br><span class="line">        Object target = invocation.getThis();</span><br><span class="line">        Assert.state(target != <span class="keyword">null</span>, <span class="string">"Target must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行参数校验，校验的是当前类，也就是说校验的是 Bean 对应的类</span></span><br><span class="line">            result = execVal.validateParameters(target, methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="comment">//doSomeThings</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="comment">//校验返回值</span></span><br><span class="line">        result = execVal.validateReturnValue(target, methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就要看看 <strong>ExecutableValidator.validateParameters</strong> 这个方法是如何实现的，为了方便阅读，这里我只保留了部分核心代码。<strong>根据包名我们大概也能猜到 ExecutableValidator.validateParameters 是 hibernate-validator 包提供的方法，而 @Validated 注解是由 Spring 提供的，所以不生效也就正常了。</strong>接下来我们继续往下走，我这里只贴部分核心的代码，中间的栈路径可以根据以下这个路径往下走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.engine.ValidatorImpl#validateParameters  </span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.BeanMetaDataManager#getBeanMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl#createBeanMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.BeanMetaDataManagerImpl#getBeanConfigurationForHierarchy</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.MetaDataProvider#getBeanConfiguration</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#retrieveBeanConfiguration</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#getFieldMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#findPropertyMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#findConstraints</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#findCascadingMetaData</span></span><br><span class="line"><span class="comment"> *  &lt;-- ...</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#getMethodMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#getConstructorMetaData</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider#getClassLevelConstraints</span></span><br><span class="line"><span class="comment"> *  &lt;-- ...</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.metadata.aggregated.BeanMetaData#hasConstraints</span></span><br><span class="line"><span class="comment"> *  --&gt; org.hibernate.validator.internal.engine.ValidatorImpl#validateParametersInContext</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorImpl</span> <span class="keyword">implements</span> <span class="title">Validator</span>, <span class="title">ExecutableValidator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validateValue(Class&lt;T&gt; beanType, String propertyName, Object value, Class&lt;?&gt;... groups) &#123;</span><br><span class="line">        Contracts.assertNotNull( beanType, MESSAGES.beanTypeCannotBeNull() );</span><br><span class="line">        sanityCheckPropertyPath( propertyName );</span><br><span class="line">        sanityCheckGroups( groups );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 bean 及其父类、超类的</span></span><br><span class="line">        BeanMetaData&lt;T&gt; rootBeanMetaData = beanMetaDataManager.getBeanMetaData( beanType );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断该 bean 是否有约束</span></span><br><span class="line">        <span class="keyword">if</span> ( !rootBeanMetaData.hasConstraints() ) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PathImpl propertyPath = PathImpl.createPathFromString( propertyName );</span><br><span class="line">        BaseBeanValidationContext&lt;T&gt; validationContext = getValidationContextBuilder().forValidateValue( beanType, rootBeanMetaData, propertyPath );</span><br><span class="line"></span><br><span class="line">        ValidationOrder validationOrder = determineGroupValidationOrder( groups );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//校验参数</span></span><br><span class="line">        <span class="keyword">return</span> validateValueInContext(validationContext, value, propertyPath, validationOrder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我调试到 <strong>rootBeanMetaData.hasConstraints()</strong> 时，判断没有约束，然后就直接返回了没有进行参数校验。我就想说看看是如何判断 Bean 是否有约束的，于是就返回上层进入 beanMetaDataManager.getBeanMetaData 中看，结果发现里面的代码有够复杂的🌚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationMetaDataProvider</span> <span class="keyword">implements</span> <span class="title">MetaDataProvider</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//获取类上所有的约束条件</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">BeanConfiguration&lt;T&gt; <span class="title">retrieveBeanConfiguration</span><span class="params">(Class&lt;T&gt; beanClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取字段上的约束条件</span></span><br><span class="line">        Set&lt;ConstrainedElement&gt; constrainedElements = getFieldMetaData( beanClass );</span><br><span class="line">        <span class="comment">//获取方法上的约束条件（包括参数、返回值）</span></span><br><span class="line">        constrainedElements.addAll( getMethodMetaData( beanClass ) );</span><br><span class="line">        <span class="comment">//获取构造函数</span></span><br><span class="line">        constrainedElements.addAll( getConstructorMetaData( beanClass ) );</span><br><span class="line">        <span class="comment">//获取类上的约束条件</span></span><br><span class="line">        Set&lt;MetaConstraint&lt;?&gt;&gt; classLevelConstraints = getClassLevelConstraints( beanClass );</span><br><span class="line">        <span class="keyword">if</span> ( !classLevelConstraints.isEmpty() ) &#123;</span><br><span class="line">            ConstrainedType classLevelMetaData =</span><br><span class="line">                <span class="keyword">new</span> ConstrainedType(ConfigurationSource.ANNOTATION, beanClass, classLevelConstraints);</span><br><span class="line">            constrainedElements.add( classLevelMetaData );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanConfiguration&lt;&gt;(ConfigurationSource.ANNOTATION, beanClass, constrainedElements, getDefaultGroupSequence( beanClass ), getDefaultGroupSequenceProvider( beanClass ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查找约束注解</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;A extends Annotation&gt; List&lt;ConstraintDescriptorImpl&lt;?&gt;&gt; findConstraintAnnotations(Constrainable constrainable, A annotation, ConstraintLocationKind type) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果包含 "jdk.internal" and "java" 下的注解，则直接不进行校验</span></span><br><span class="line">          <span class="keyword">if</span> ( constraintCreationContext.getConstraintHelper().isJdkAnnotation( annotation.annotationType() ) ) &#123;</span><br><span class="line">          <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      List&lt;Annotation&gt; constraints = newArrayList();</span><br><span class="line">      Class&lt;? extends Annotation&gt; annotationType = annotation.annotationType();</span><br><span class="line">      <span class="comment">//判断是否有约束条件，也就我们经常配置的 @NotNull，@Min 这类注解</span></span><br><span class="line">      <span class="keyword">if</span> ( constraintCreationContext.getConstraintHelper().isConstraintAnnotation( annotationType ) ) &#123;</span><br><span class="line">          constraints.add( annotation );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这个没用过，暂时跳过</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( constraintCreationContext.getConstraintHelper().isMultiValueConstraint( annotationType ) ) &#123;</span><br><span class="line">          constraints.addAll( constraintCreationContext.getConstraintHelper().getConstraintsFromMultiValueConstraint( annotation ) );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> constraints.stream()</span><br><span class="line">          .map( c -&gt; buildConstraintDescriptor( constrainable, c, type ) )</span><br><span class="line">          .collect( Collectors.toList() );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建级联元数据构造器，也就是我们常用的 @Valid，在 Bean 中如果我们要对对象属性进行校验，</span></span><br><span class="line">    <span class="comment">//需要在该属性上添加 @Valid，此处便是如此</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CascadingMetaDataBuilder <span class="title">getCascadingMetaData</span><span class="params">(JavaBeanAnnotatedElement annotatedElement, Map&lt;TypeVariable&lt;?&gt;, CascadingMetaDataBuilder&gt; containerElementTypesCascadingMetaData)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CascadingMetaDataBuilder.annotatedObject( annotatedElement.getType(), annotatedElement.isAnnotationPresent( Valid<span class="class">.<span class="keyword">class</span> ),</span></span><br><span class="line"><span class="class">            <span class="title">containerElementTypesCascadingMetaData</span>, <span class="title">getGroupConversions</span>( <span class="title">annotatedElement</span>.<span class="title">getAnnotatedType</span>() ) )</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺着上面的栈路径一直往下走，最终发现最核心的几个方法是 <strong>getFieldMetaData</strong>、<strong>getMethodMetaData</strong>、<strong>getConstructorMetaData</strong>、<strong>getClassLevelConstraints</strong>，这个几方法都是用于获取约束和级联元数据。那么里面到底是怎么获取约束元数据的呢，咱继续往里钻，可以看到最终调用了 <strong>findConstraintAnnotations</strong> 获取约束元数据，也就是我们平时用到的 @NotNull，@Min 等注解，通过 <strong>getCascadingMetaData</strong> 获取级联元数据，也就是 @Valid 注解。看到这，是不是很容易就能想到，知道我加上 @Valid 就能成功校验了呢？</p><p>于是我尝试了一波，果然没问题。嗯~ 长见识了😂。由于时间有限，ValidatorImpl.validateParametersInContext() 方法我就没有深入进去看了。感兴趣的小伙伴可以自行去看看！！🌝</p><h3 id="那么-Controller-为啥直接添加-Validated-或者-Valid-就可以呢？"><a href="#那么-Controller-为啥直接添加-Validated-或者-Valid-就可以呢？" class="headerlink" title="那么 Controller 为啥直接添加 @Validated 或者 @Valid 就可以呢？"></a>那么 Controller 为啥直接添加 @Validated 或者 @Valid 就可以呢？</h3><p>明白了在应用服务实现，准确的说应该是普通 Bean 中应该怎么配置之 @Validated 和 @Valid 使其生效之后，我就很好奇为啥 Controller 只需要单独在方法上配置 @Validated 或者 @Valid 就能成功校验呢？</p><p>还记得上面通过 IDE 查看应用 @Validated 注解的类时，我们发现了 MethodValidationPostProcessor，还有另外几个类一看就很像 Controller 参数解析相关的类：</p><img src="/images/6a453dcb7830c8ba9ebead61cb4942d9.png" alt="截图" style="zoom:100%;" /><p>我在这几个类上各打了一个断点，最终进入的是 AbstractMessageConverterMethodArgumentResolver。</p><p>ok，那就看看他是怎么实现的，这里只贴了很参数校验相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMessageConverterMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">            <span class="comment">//获取分组信息</span></span><br><span class="line">            Object[] validationHints = ValidationAnnotationUtils.determineValidationHints(ann);</span><br><span class="line">            <span class="keyword">if</span> (validationHints != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//进行校验</span></span><br><span class="line">                binder.validate(validationHints);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationAnnotationUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object[] determineValidationHints(Annotation ann) &#123;</span><br><span class="line">        Class&lt;? extends Annotation&gt; annotationType = ann.annotationType();</span><br><span class="line">        String annotationName = annotationType.getName();</span><br><span class="line">        <span class="comment">//如果是 @valid 注解直接返回一个空数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"javax.validation.Valid"</span>.equals(annotationName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_OBJECT_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是 @validated 则返回其分组信息</span></span><br><span class="line">        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Object hints = validatedAnn.value();</span><br><span class="line">            <span class="keyword">return</span> convertValidationHints(hints);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (annotationType.getSimpleName().startsWith(<span class="string">"Valid"</span>)) &#123;</span><br><span class="line">            Object hints = AnnotationUtils.getValue(ann);</span><br><span class="line">            <span class="keyword">return</span> convertValidationHints(hints);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBinder</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistry</span>, <span class="title">TypeConverter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object... validationHints)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处是关键所在，这里获取的是参数！！！和普通的 Bean 获取到的却是 Bean 本身</span></span><br><span class="line">        Object target = getTarget();</span><br><span class="line">        Assert.state(target != <span class="keyword">null</span>, <span class="string">"No target to validate"</span>);</span><br><span class="line">        BindingResult bindingResult = getBindingResult();</span><br><span class="line">        <span class="comment">// Call each validator with the same binding result</span></span><br><span class="line">        <span class="keyword">for</span> (Validator validator : getValidators()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator <span class="keyword">instanceof</span> SmartValidator) &#123;</span><br><span class="line">                ((SmartValidator) validator).validate(target, bindingResult, validationHints);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (validator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                validator.validate(target, bindingResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，对于 Controller 不论是直接在参数上加上 @Validated 或者 @Valid 注解，都会进入到校验方法，<strong>而且校验的就是参数！！！而 Bean 校验的却是 Bean 本身！！！</strong></p><h3 id="MethodValidationPostProcessor-和-AbstractMessageConverterMethodArgumentResolver-是怎么被注册到-BeanFactory-的？"><a href="#MethodValidationPostProcessor-和-AbstractMessageConverterMethodArgumentResolver-是怎么被注册到-BeanFactory-的？" class="headerlink" title="MethodValidationPostProcessor 和 AbstractMessageConverterMethodArgumentResolver 是怎么被注册到 BeanFactory 的？"></a>MethodValidationPostProcessor 和 AbstractMessageConverterMethodArgumentResolver 是怎么被注册到 BeanFactory 的？</h3><p>明白了 @Validated 的拦截实现的原理后，那么就只剩最后一个问题了，MethodValidationPostProcessor 和 AbstractMessageConverterMethodArgumentResolver 是怎么被注册到 BeanFactory 的。</p><p>其实不用看源码大概有也能猜到是 Spring Boot 自动装配的。为了印证一下，我还是贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(ExecutableValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnResource</span>(<span class="title">resources</span> </span>= <span class="string">"classpath:META-INF/services/javax.validation.spi.ValidationProvider"</span>)</span><br><span class="line"><span class="meta">@Import</span>(PrimaryDefaultValidatorPostProcessor<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ValidationAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MethodValidationPostProcessor <span class="title">methodValidationPostProcessor</span><span class="params">(Environment environment, @Lazy Validator validator, ObjectProvider&lt;MethodValidationExcludeFilter&gt; excludeFilters)</span> </span>&#123;</span><br><span class="line">        FilteredMethodValidationPostProcessor processor = <span class="keyword">new</span> FilteredMethodValidationPostProcessor(excludeFilters.orderedStream());</span><br><span class="line">        <span class="keyword">boolean</span> proxyTargetClass = environment.getProperty(<span class="string">"spring.aop.proxy-target-class"</span>, Boolean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>)</span>;</span><br><span class="line">        processor.setProxyTargetClass(proxyTargetClass);</span><br><span class="line">        processor.setValidator(validator);</span><br><span class="line">        <span class="keyword">return</span> processor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外就是 AbstractMessageConverterMethodArgumentResolver 的几个实现类，均由 RequestMappingHandlerAdapter 实例化，而 RequestMappingHandlerAdapter 大家知道有 WebMvcAutoConfiguration 自动装配，时间原因，这就不看了。</p><img src="/images/2848df20caae7fcdd6277d991b9f98d2.png" alt="截图" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestMappingHandlerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractHandlerMethodAdapter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title">getDefaultArgumentResolvers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Annotation-based argument resolution</span></span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">false</span>));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMapMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> PathVariableMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> PathVariableMapMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> MatrixVariableMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> MatrixVariableMapMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">false</span>));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestHeaderMapMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> SessionAttributeMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestAttributeMethodArgumentResolver());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Type-based argument resolution</span></span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ServletRequestMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ServletResponseMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="keyword">this</span>.requestResponseBodyAdvice));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RedirectAttributesMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ModelMethodProcessor());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> MapMethodProcessor());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ErrorsMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> SessionStatusMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> UriComponentsBuilderMethodArgumentResolver());</span><br><span class="line">        <span class="keyword">if</span> (KotlinDetector.isKotlinPresent()) &#123;</span><br><span class="line">            resolvers.add(<span class="keyword">new</span> ContinuationHandlerMethodArgumentResolver());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Custom arguments</span></span><br><span class="line">        <span class="keyword">if</span> (getCustomArgumentResolvers() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolvers.addAll(getCustomArgumentResolvers());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Catch-all</span></span><br><span class="line">        resolvers.add(<span class="keyword">new</span> PrincipalMethodArgumentResolver());</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="keyword">true</span>));</span><br><span class="line">        resolvers.add(<span class="keyword">new</span> ServletModelAttributeMethodProcessor(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resolvers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>1、在普通 Bean 中如果要通过注解的方式使用 hibernate-validator 进行校验的话，需要在类上添加 @Validated 注解，同时在方法上添加 @Valid 注解。或者也可以直接使用 @NotNull 等注解。</p><p>2、普通 Bean 使用 @Validated 是通过动态代理完成的。具体的拦截器便是他 MethodValidationInterceptor。</p><p>3、Controller 层之所以能 @Validated 和 @Valid 二选一，是因为校验的是参数本身，而普通 Bean 校验的是 Bean 本身。</p><p>4、至此，相信大家就不会没配置好 @Validated 导致失效了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近在落地 DDD，希望对 command 进行参数校验，由于部分流量入口是 MQ，所以希望在应用层是用 @Validated 进行参数校验，结果。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Controller-中使用-Valida</summary>
      
    
    
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>kafka 消费者高 cpu 问题排查</title>
    <link href="http://example.com/2023/04/14/kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E9%AB%98-cpu-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>http://example.com/2023/04/14/kafka-%E6%B6%88%E8%B4%B9%E8%80%85%E9%AB%98-cpu-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2023-04-14T15:31:22.000Z</published>
    <updated>2023-04-14T15:48:38.289Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天本来打算愉快的划水，运维小哥突然找我说测试环境应用 cpu 一直居高不下，我一看告警还真是…</p></blockquote><h3 id="cpu-高问题排查思路"><a href="#cpu-高问题排查思路" class="headerlink" title="cpu 高问题排查思路"></a>cpu 高问题排查思路</h3><h4 id="首先还是老套路："><a href="#首先还是老套路：" class="headerlink" title="首先还是老套路："></a>首先还是老套路：</h4><ol><li>先查看 cpu 高的线程是哪些</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp &lt;pid&gt;</span><br></pre></td></tr></table></figure><img src="/images/9a05c976-5255-48db-918a-2cf6e7f8047d.png" alt="截图" style="zoom:100%"><ol start="2"><li>查看线程的堆栈信息</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将线程 id 转换为 16 进制</span><br><span class="line"><span class="built_in">printf</span> <span class="string">'%x\n'</span> &lt;tid&gt;</span><br><span class="line"></span><br><span class="line">//获取线程号后 50 行堆栈信息</span><br><span class="line">jstack &lt;pid&gt; | grep &lt;tid&gt; -A 50</span><br></pre></td></tr></table></figure><p>这里我就直接用线程名称去查了。</p><img src="/images/dccda0a5-30a3-443e-a5b7-62ba3f83d12d.png" alt="截图" style="zoom:100%"><p>看堆栈信息定位到是 kafka 消费者消费消息，导致 cpu 居高不下，正常情况下 kafka 消费者 cpu 飚高都是有大量的消息，我第一个感觉就是测试在进行压测，结果一看，打脸了🤔。</p><img src="/images/2ebfeb48-41ce-460f-bd4e-14ef2824b82e.png" alt="截图" style="zoom:100%"><p>可以看到，lag 是 0 或者负数，我又刷新了几次基本上没有多少消息，<strong>这里留个心眼，后面我们在好好唠唠</strong>。</p><p>那么问题就来了，没有消息为啥消费者 cpu 会飚高… 突然灵机一动，会不会是消费者数太多了，导致循环去调用 poll 方法，造成整个节点 cpu 飚高。然后就屁颠屁颠的把所有主题的消费者数调小了，然鹅想想很美好，现实很骨感… 重启后节点的 cpu 依然居高不下。</p><h4 id="遇到不懂就问度娘"><a href="#遇到不懂就问度娘" class="headerlink" title="遇到不懂就问度娘"></a>遇到不懂就问度娘</h4><p>在网上逛了一圈，看到许多相似的场景，各种操作都试了一遍，还是没什么用🙃，kafka 的 github 仓库我也去逛了一圈，发现也有很多 cpu 高得场景，大多数都是建议升级客户端版本，忘了说我司目前用的还是 <strong>0.11.2</strong>，总之逛了一圈没有起到太大的帮助。</p><p>接着就是一波虾皮操作，显示生成了火焰图，看看 consumer poll 到底为啥一直占用 cpu，下面是一张火焰图：</p><img src="/images/6a2a9517-818a-4a3e-a9be-2b5b40dac23e.png" alt="截图" style="zoom:100%"><p>虽然 poll 方法占用 cpu 耗时很长，但是仔细看又觉得没啥问题，是正常的在处理网络请求，这个时候我甚至一度怀疑是 kafka 客户端的 bug 😂。</p><h3 id="有耐心问题迟早能解决"><a href="#有耐心问题迟早能解决" class="headerlink" title="有耐心问题迟早能解决"></a>有耐心问题迟早能解决</h3><p>还记的我们之前提了一嘴那张截图吗，没错就是下面这张</p><img src="/images/2ebfeb48-41ce-460f-bd4e-14ef2824b82e.png" alt="截图" style="zoom:100%"><p>图中 lag 出现负数，其实 lag 出现负数还是很常见的，但问题就出在我排查了这么久图中的 lag 好像没变化过，而且一直是负数，那就很值得注意了。</p><p>我们还是先说说 lag 是怎么计算的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lag = HW - consumerOffset</span><br></pre></td></tr></table></figure><p><strong>HW: 高水位，通常等于所有 ISR 中最小的 LEO，详细的可以看看<a href="https://www.cnblogs.com/koktlzz/p/14580109.html" target="_blank" rel="noopener">大佬的博客</a></strong></p><p><strong>consumerOffset: 表示消费者提交的消费位移</strong></p><p>那么 lag 为啥会出现负数呢，由于我本身并未看过源码，所以从网上找了一个我认为比较是能说的通的解释:</p><blockquote><p>Producer 的 offset 是通过 JMX 轮询获得的，Consumer 的 offset 是从 kafka 内的 __consumer_offsets 的 topic 中直接读取到的，很明显轮询获取 offset 比 直接从 topic 拿 offset 慢一点，也就可能会出现 Lag 计算后为负数的情况。</p></blockquote><p>OK，回到正题，lag 长时间是负数说明 consumerOffset 一直大于 HW，那么出现这个问题的原因大概率是 HW 一直不更新，因为 HW 只要更新其实 lag 很快就能变回 0。那么 HW 是什么时候更新的呢，<strong>其实是 Follower 副本同步 Leader 副本数据时，Leader 副本会对比 Follower 拉取数据的 offset 和 Leader 自身的 LEO 去更新 HW，所以通常 HW 需要 Follower 多同步一轮才会更新</strong>。</p><p><strong>那么 HW 不更新，只能说明 Follower 没有去同步数据</strong>，想到这，我立马去看了下消费组的副本状态，发现有一个 broker 所有的分区副本都不在 ISR 中。那么基本上确定这个 broker 是出现问题了，但是这和我消费者 cpu 高有什么关系呢？</p><img src="/images/382ce5cb-4dfe-481f-88ca-fc2cd9313431.png" alt="截图" style="zoom:100%"><p>这时运维小哥告诉我，poll 平均每 3ms 就请求一次，导致 cpu 飚高。纳尼？？？我的 poll timeout 明明是 100ms，怎么 3ms 一次呢，这明显有问题呀，运维小哥发了一下抓包的截图给我：</p><img src="/images/16814578551784.png" alt="截图" style="zoom:100%"><p><strong>kafka broker response 中提示 Not Leader For Partition</strong>，这不就和上面的猜想对上了吗，看看 chatgpt 给出的解释:</p><img src="/images/16b2e8bc-06a3-4166-bf25-6815077beb93.png" alt="截图" style="zoom:100%"><p>至此问题就排查了差不多了，那么接下来就是解决。由于是在测试环境发现的，解决方式也很粗暴，就是直接把 topic 直接删除了，然后重新创建。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>遇到涉及网络相关的问题，可以抓个包瞧瞧，说不定思路一下就打开了。</li><li>如果实在生产环境遇到这类问题，那么该怎么处理 broker 呢，这个得好好琢磨琢磨，目前思路是从 controller 下手。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;今天本来打算愉快的划水，运维小哥突然找我说测试环境应用 cpu 一直居高不下，我一看告警还真是…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;cpu-高问题排查思路&quot;&gt;&lt;a href=&quot;#cpu-高问题排查思路&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="kafka" scheme="http://example.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>wireshark 抓包 java应用中的 https 请求</title>
    <link href="http://example.com/2023/04/03/wireshark-%E6%8A%93%E5%8C%85-java%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84-https-%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2023/04/03/wireshark-%E6%8A%93%E5%8C%85-java%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84-https-%E8%AF%B7%E6%B1%82/</id>
    <published>2023-04-03T07:08:41.000Z</published>
    <updated>2023-04-03T07:12:39.504Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近生产中请求第三方接口的服务频繁告警，接口响应过慢，我们这边使用的 httpclient 连接池，各项配置看起来都没太大的问题，于是就想着说抓包看看是否有网络层面的问题还是的确是第三方接口慢。</p></blockquote><h2 id="通过-jsslkeylog-获取-sslkeylog"><a href="#通过-jsslkeylog-获取-sslkeylog" class="headerlink" title="通过 jsslkeylog 获取 sslkeylog"></a>通过 <a href="https://github.com/jsslkeylog/jsslkeylog" target="_blank" rel="noopener">jsslkeylog</a> 获取 sslkeylog</h2><h3 id="wireshark-中-https-显示密文的样子"><a href="#wireshark-中-https-显示密文的样子" class="headerlink" title="wireshark 中 https 显示密文的样子"></a>wireshark 中 https 显示密文的样子</h3><p>有用过 wireshark 抓包 https 的大佬应该都知道，https 是有加密的，直接用 wireshark 抓包展示的全都是密文，如下图：<br><img src="/images/9e5440f2db4de1185099e8c1e91edfc.png" alt="截图" style="zoom:100%"><br>可以看到，具体的 https 请求数据都被加密了。</p><h3 id="如何让-https-在-wireshark-显示明文"><a href="#如何让-https-在-wireshark-显示明文" class="headerlink" title="如何让 https 在 wireshark 显示明文"></a>如何让 https 在 wireshark 显示明文</h3><p>wireshark 中解密 https 请求的<a href="https://www.google.com.hk/search?q=wireshark+%E8%A7%A3%E5%AF%86+https&newwindow=1&sxsrf=APwXEdfQwqHE-Fyw3B1hnQNyxby131_KyA:1680505936629&ei=UHwqZJj6Je3f2roPovmx8A4&ved=0ahUKEwiY4pS7lI3-AhXtr1YBHaJ8DO4Q4dUDCA8&uact=5&oq=wireshark+%E8%A7%A3%E5%AF%86+https&gs_lcp=Cgxnd3Mtd2l6LXNlcnAQAzIHCAAQgAQQDDIHCAAQgAQQDDIHCAAQgAQQDDoECCMQJzoFCAAQgAQ6CAgAEAgQBBAeSgQIQRgAUABYowpgtgxoAHABeACAAc4CiAH5DJIBBzAuMS41LjGYAQCgAQHAAQE&sclient=gws-wiz-serp" target="_blank" rel="noopener">方式</a>有多种，这里使用的方式是获取 https 请求时的 sslkeylog，使用到了一个 javaagent 工具 <a href="https://github.com/jsslkeylog/jsslkeylog" target="_blank" rel="noopener">jsslkeylog</a>，通过修改字节码达到发送 https 请求时将使用到的 sslkeylog 写入到本地磁盘的效果。<br>具体流程也很简单：<br>1、下载 jsslkeylog jar 包<br>2、启动命令中加入 -javaagent:/path_to_jar/jSSLKeyLog.jar=/path_to_log/sslkeylog.log<br>3、启动应用发起 https 请求<br>4、之后应该就会在配置的 /path_to_log 中看到对应的 sslkeylog<br><img src="/images/05a6bf5febf9f1b4673920a5d1697bdc.png" alt="截图" style="zoom:100%"><br>5、之后将 log 配置到 wireshark 中，prfferences -&gt; protocols -&gt; tls<br><img src="/images/3b0485a52fcfe450902e8cb06b8b3ca1.png" alt="截图" style="zoom:100%"><br>配置完成之后，就能看到原本的密文已经变成明文了，之后就能愉快的分析了🌝<br><img src="/images/ba3709b43b60602fc22efe0525515d0e.png" alt="截图" style="zoom:100%"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近生产中请求第三方接口的服务频繁告警，接口响应过慢，我们这边使用的 httpclient 连接池，各项配置看起来都没太大的问题，于是就想着说抓包看看是否有网络层面的问题还是的确是第三方接口慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>k8s 搭建</title>
    <link href="http://example.com/2023/03/31/k8s-%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2023/03/31/k8s-%E6%90%AD%E5%BB%BA/</id>
    <published>2023-03-31T15:45:37.000Z</published>
    <updated>2023-03-31T15:46:40.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s搭建"><a href="#k8s搭建" class="headerlink" title="k8s搭建"></a>k8s搭建</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>本文系搭建 kubernetes v1.21.3 版本集群笔记，使用三台虚拟机作为 CentOS7.9 系统测试机，安装 kubeadm、kubelet、kubectl 均使用 yum 安装，网络组件选用的是 flannel。</p><hr><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>部署集群没有特殊说明均使用 root 用户执行命令。</p><p>2.1 硬件信息</p><table><thead><tr><th>ip</th><th>hostname</th><th>mem</th><th>disk</th><th>explain</th></tr></thead><tbody><tr><td>192.168.85.2</td><td>192.168.85.2</td><td>2G</td><td>40GB</td><td>k8s 控制平面节点</td></tr><tr><td>192.168.85.3</td><td>192.168.85.3</td><td>2G</td><td>40GB</td><td>k8s 执行节点1</td></tr><tr><td>192.168.85.4</td><td>192.168.85.4</td><td>2G</td><td>40GB</td><td>k8s 执行节点2</td></tr></tbody></table><p>2.2 软件信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">software    version</span><br><span class="line">CentOS    CentOS Linux release 7.9.2009 (Core)</span><br><span class="line">Kubernetes    1.21.3</span><br><span class="line">Docker    20.10.8</span><br><span class="line">Kernel    5.4.138-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure><p>2.3 禁用 swap<br>swap 仅当内存不够时会使用硬盘块充当额外内存，硬盘的 io 较内存差距极大，禁用 swap 以提高性能各节点均需执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a </span><br><span class="line">cp /etc/fstab  /etc/fstab.bak</span><br><span class="line">cat /etc/fstab.bak | grep -v swap &gt; /etc/fstab</span><br></pre></td></tr></table></figure><p>2.4 关闭 SELinux</p><p>关闭 SELinux，否则 kubelet 挂载目录时可能报错 Permission denied，可以设置为 permissive 或 disabled，permissive 会提示 warn 信息各节点均需执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0 </span><br><span class="line">sed -i <span class="string">'s/^SELINUX=.*/SELINUX=disabled/'</span> /etc/selinux/config</span><br></pre></td></tr></table></figure><p>2.5 设置时区、同步时间</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl <span class="built_in">set</span>-timezone Asia/Shanghai </span><br><span class="line">systemctl <span class="built_in">enable</span> --now chronyd</span><br></pre></td></tr></table></figure><p>查看同步状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status</span><br></pre></td></tr></table></figure><p>2.6 关闭防火墙</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure><br/><h3 id="安装必要依赖"><a href="#安装必要依赖" class="headerlink" title="安装必要依赖"></a>安装必要依赖</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>3.1 添加 aliyun docker-ce yum 源 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p> 重建 yum 缓存 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>3.2 安装 Docker</p><p>查看可用 docker 版本 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64 --showduplicates | sort -r</span><br></pre></td></tr></table></figure><p><strong>==安装指定版本 Docker==</strong></p><p>yum install -y docker-ce-20.10.14-3.el7</p><p>这里以安装 20.10.14 版本举例，注意版本号不包含 : 与之前的数字。</p><p>3.3 确保网络模块开机自动加载</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep overlay </span><br><span class="line">lsmod | grep br_netfilter</span><br></pre></td></tr></table></figure><p>若上面命令无返回值输出或提示文件不存在，需执行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/modules-load.d/docker.conf &lt;&lt;EOF </span><br><span class="line">overlay </span><br><span class="line">br_netfilter </span><br><span class="line">EOF</span><br><span class="line">modprobe overlay </span><br><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><p>3.4 使桥接流量对 iptables 可见<br>各个节点均需执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt;EOF </span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>验证是否生效，均返回 1 即正确。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -n net.bridge.bridge-nf-call-iptables </span><br><span class="line">sysctl -n net.bridge.bridge-nf-call-ip6tables</span><br></pre></td></tr></table></figure><p>3.5 配置 Docker</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br></pre></td></tr></table></figure><p>修改 cgroup 驱动为 systemd [k8s官方推荐]、限制容器日志量、修改存储类型，最后的 docker 家目录可修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"exec-opts"</span>: [<span class="string">"native.cgroupdriver=systemd"</span>],</span><br><span class="line">  <span class="string">"log-driver"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">  <span class="string">"log-opts"</span>: &#123;</span><br><span class="line">    <span class="string">"max-size"</span>: <span class="string">"100m"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span>,</span><br><span class="line">  <span class="string">"storage-opts"</span>: [</span><br><span class="line">    <span class="string">"overlay2.override_kernel_check=true"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://gp8745ui.mirror.aliyuncs.com"</span>],</span><br><span class="line">  <span class="string">"data-root"</span>: <span class="string">"/data/docker"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>服务脚本第 13 行修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --default-ulimit core=0:0</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>添加开机自启，立即启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure><p>3.6 验证 Docker 是否正常</p><p>查看docker信息，判断是否与配置一致</p><br/><h3 id="部署-Kubernetes-集群"><a href="#部署-Kubernetes-集群" class="headerlink" title="部署 Kubernetes 集群"></a>部署 Kubernetes 集群</h3><p>如未说明，各节点均需执行如下步骤：</p><p>4.1 添加 kubernetes 源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>重建yum缓存，输入y添加证书认证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure><p>4.2 安装 kubeadm、kubelet、kubectl<br>各节点均需安装 kubeadm、kubelet</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce.x86_64 --showduplicates | sort -r</span><br><span class="line">version=1.21.3-0</span><br><span class="line">yum install -y kubelet-v1.21.0 kubeadm-v1.21.0 kubectl-v1.21.0</span><br><span class="line"></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet --now</span><br></pre></td></tr></table></figure><p>4.3 配置自动补全命令</p><p>安装 bash 自动补全插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bash-completion -y</span><br></pre></td></tr></table></figure><p>设置 kubectl 与 kubeadm 命令补全，下次 login 生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl completion bash &gt;/etc/bash_completion.d/kubectl</span><br><span class="line">kubeadm completion bash &gt; /etc/bash_completion.d/kubeadm</span><br></pre></td></tr></table></figure><p>4.4 为 Docker 设定使用的代理服务(暂跳过该步骤，由阿里云镜像解决)<br>Kubeadm 部署 Kubernetes 集群的过程中，默认使用 Google 的 Registry 服务 k8s.gcr.io 上的镜像，例如k8s.grc.io/kube-apiserver 等，但国内无法访问到该服务。必要时，可自行设置合适的代理来获取相关镜像，或者从 Dockerhub 上下载镜像至本地后自行对镜像打标签。</p><p>这里简单说明一下设置代理服务的方法。编辑 /lib/systemd/system/docker.service 文件，在 [Service] 配置段中添加类似如下内容，其中的 PROXY_SERVER_IP 和 PROXY_PORT 要按照实际情况修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Environment=<span class="string">"HTTP_PROXY=http://<span class="variable">$PROXY_SERVER_IP</span>:<span class="variable">$PROXY_PORT</span>"</span></span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=https://<span class="variable">$PROXY_SERVER_IP</span>:<span class="variable">$PROXY_PORT</span>"</span></span><br><span class="line">Environment=<span class="string">"NO_PROXY=192.168.4.0/24"</span></span><br></pre></td></tr></table></figure><p>配置完成后需要重载 systemd，并重新启动 docker 服务：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>需要特别说明的是，由 kubeadm 部署的 Kubernetes 集群上，集群核心组件 kube-apiserver、kube-controller-manager、kube-scheduler 和 etcd 等均会以静态 Pod 的形式运行，它们所依赖的镜像文件默认来自于 k8s.gcr.io 这一 Registry 服务之上。但我们无法直接访问该服务，常用的解决办法有如下两种，本示例将选择使用更易于使用的前一种方式：</p><p>使用能够到达该服务的代理服务<br>使用国内的镜像服务器上的服务，例如 gcr.azk8s.cn/google_containers 和 registry.aliyuncs.com/google_containers 等（经测试，v1.22.0 版本已停用）<br>4.5 查看指定 k8s 版本需要哪些镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list --kubernetes-version v1.21.0</span><br><span class="line"></span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.21.0</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.21.0</span><br><span class="line">k8s.gcr.io/pause:3.4.1</span><br><span class="line">k8s.gcr.io/etcd:3.4.13-0</span><br><span class="line">k8s.gcr.io/coredns/coredns:v1.8.0</span><br></pre></td></tr></table></figure><p>4.6 拉取镜像</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim pullimages.sh</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># pull images</span></span><br><span class="line"> </span><br><span class="line">ver=v1.21.0</span><br><span class="line">registry=registry.cn-hangzhou.aliyuncs.com/google_containers</span><br><span class="line">images=`kubeadm config images list --kubernetes-version=<span class="variable">$ver</span> |awk -F <span class="string">'/'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> <span class="variable">$images</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$image</span> != coredns ];<span class="keyword">then</span></span><br><span class="line">    docker pull <span class="variable">$&#123;registry&#125;</span>/<span class="variable">$image</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ];<span class="keyword">then</span></span><br><span class="line">        docker tag <span class="variable">$&#123;registry&#125;</span>/<span class="variable">$image</span> k8s.gcr.io/<span class="variable">$image</span></span><br><span class="line">        docker rmi <span class="variable">$&#123;registry&#125;</span>/<span class="variable">$image</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"ERROR: 下载镜像报错，<span class="variable">$image</span>"</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    docker pull coredns/coredns:1.8.0</span><br><span class="line">    docker tag coredns/coredns:1.8.0  k8s.gcr.io/coredns/coredns:v1.8.0</span><br><span class="line">    docker rmi coredns/coredns:1.8.0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>4.7 修改 kubelet 配置默认 cgroup driver</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/lib/kubelet</span><br><span class="line">cat &gt; /var/lib/kubelet/config.yaml &lt;&lt;EOF</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">cgroupDriver: systemd</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>4.8 初始化 master 节点<br>仅 192.168.85.2 节点需要执行此步骤。</p><p>4.8.1 生成 kubeadm 初始化配置文件<br>[可选] 仅当需自定义初始化配置时用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm-config.yaml</span><br></pre></td></tr></table></figure><p>修改配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 1.2.3.4</span><br></pre></td></tr></table></figure><p> 替换为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.85.2</span><br><span class="line">  name: 192.168.85.2</span><br><span class="line">kubernetesVersion: 1.21.0</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubernetesVersion: 1.21.0</span><br><span class="line">networking:</span><br><span class="line">  podSubnet: <span class="string">"10.244.0.0/16"</span></span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br></pre></td></tr></table></figure><p>4.8.2 测试环境是否正常</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init phase preflight</span><br></pre></td></tr></table></figure><p>4.8.3 初始化 master<br>10.244.0.0/16 是 flannel 固定使用的 IP 段，设置取决于网络组件要求。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config=kubeadm-config.yaml --ignore-preflight-errors=2 --upload-certs | tee kubeadm-init.log</span><br></pre></td></tr></table></figure><p>4.8.4 为日常使用集群的用户添加 kubectl 使用权限</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su - iuskye</span><br><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/admin.conf</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/admin.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export KUBECONFIG=<span class="variable">$HOME</span>/.kube/admin.conf"</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>4.8.5 配置 master 认证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export KUBECONFIG=/etc/kubernetes/admin.conf'</span> &gt;&gt; /etc/profile </span><br><span class="line">. /etc/profile</span><br></pre></td></tr></table></figure><p>如果不配置这个，会提示如下输出：The connection to the server localhost:8080 was refused - did you specify the right host or port?<br>此时 master 节点已经初始化成功，但是还未安装网络组件，还无法与其他节点通讯。</p><p>4.8.6 安装网络组件<br>以 flannel 为例：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -o kube-flannel.yml https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml    <span class="comment"># 这里下载镜像非常慢，我还是先手动拉下来吧，不行就多试几次</span></span><br><span class="line">docker pull quay.io/coreos/flannel:v0.14.0</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><p>4.8.7 查看 192.168.85.2 节点状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">192.168.85.2   Ready    control-plane,master   15d   v1.21.0</span><br><span class="line">192.168.85.3   Ready    &lt;none&gt;                 15d   v1.21.0</span><br><span class="line">192.168.85.4   Ready    &lt;none&gt;                 15d   v1.21.0</span><br></pre></td></tr></table></figure><p>如果 STATUS 提示 NotReady，可以通过 kubectl describe node 192.168.85.2 查看具体的描述信息，性能差的服务器到达 Ready 状态时间会长些。</p><p>4.9 初始化 node 节点并加入集群<br>4.9.1 获取加入 kubernetes 的命令<br>访问 192.168.85.2 输入创建新 token 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm token create --<span class="built_in">print</span>-join-command</span><br></pre></td></tr></table></figure><p>同时输出加入集群的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.85.2:6443 --token zukr14.dg1pxt9k9gndzqkl --discovery-token-ca-cert-hash sha256:0b57947ccd86cea8b7af2490fde858f3870e63bf35bbb0a567c702029376e9e5</span><br></pre></td></tr></table></figure><p>这个 token 也可以使用上述 master 上执行的初始化输出结果。</p><p>4.9.2 在 node 节点上执行加入集群的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.85.2:6443 --token zukr14.dg1pxt9k9gndzqkl --discovery-token-ca-cert-hash sha256:0b57947ccd86cea8b7af2490fde858f3870e63bf35bbb0a567c702029376e9e5</span><br></pre></td></tr></table></figure><p>4.10 查看集群节点状态</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">NAME           STATUS   ROLES                  AGE   VERSION</span><br><span class="line">192.168.85.2   Ready    control-plane,master   15d   v1.21.0</span><br><span class="line">192.168.85.3   Ready    &lt;none&gt;                 15d   v1.21.0</span><br><span class="line">192.168.85.4   Ready    &lt;none&gt;                 15d   v1.21.0</span><br></pre></td></tr></table></figure><p>4.11 部署 Dashboard<br>4.11.1 部署</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o recommended.yaml https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>默认 Dashboard 只能集群内部访问，修改 Service 为 NodePort 类型，暴露到外部：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vi recommended.yaml</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">      nodePort: 30001</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f recommended.yaml    <span class="comment"># 这里下载镜像非常慢，我还是先手动拉下来吧，不行就多试几次</span></span><br><span class="line">docker pull kubernetesui/dashboard:v2.3.1</span><br><span class="line">docker pull kubernetesui/metrics-scraper:v1.0.6</span><br><span class="line"></span><br><span class="line">kubectl apply -f recommended.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pods,svc -n kubernetes-dashboard</span><br><span class="line">NAME                                             READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-856586f554-nb68k   0/1     ContainerCreating   0          52s</span><br><span class="line">pod/kubernetes-dashboard-67484c44f6-shtz7        0/1     ContainerCreating   0          52s</span><br><span class="line">NAME                                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   10.96.188.208   &lt;none&gt;        8000/TCP        52s</span><br><span class="line">service/kubernetes-dashboard        NodePort    10.97.164.152   &lt;none&gt;        443:30001/TCP   53s</span><br></pre></td></tr></table></figure><p>查看状态正在创建容器中，稍后再次查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NAME                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-856586f554-nb68k   1/1     Running   0          2m11s</span><br><span class="line">pod/kubernetes-dashboard-67484c44f6-shtz7        1/1     Running   0          2m11s</span><br><span class="line">NAME                                TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)         AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   10.96.188.208   &lt;none&gt;        8000/TCP        2m11s</span><br><span class="line">service/kubernetes-dashboard        NodePort    10.97.164.152   &lt;none&gt;        443:30001/TCP   2m12s</span><br></pre></td></tr></table></figure><p>访问地址：<a href="https://NodeIP:30001；使用">https://NodeIP:30001；使用</a> Firefox 浏览器，Chrome 浏览器打不开不信任 SSL 证书的网站。</p><p>创建 service account 并绑定默认 cluster-admin 管理员集群角色：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create serviceaccount dashboard-admin -n kube-system</span><br><span class="line">kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-admin</span><br><span class="line">kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk <span class="string">'/dashboard-admin/&#123;print $1&#125;'</span>)</span><br></pre></td></tr></table></figure><p>这里需要注意粘贴的时候有可能被换行，如果被换行，可在记事本中设置为一行。</p><p>使用输出的 token 登录 Dashboard。</p><br/><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>1、dial tcp 10.96.0.1:443: connect: no route to host</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl stop kubelet</span><br><span class="line">iptables --flush</span><br><span class="line">iptables -tnat --flush</span><br><span class="line">systemctl start kubelet</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>2、failed to delegate add: failed to set bridge addr: “cni0“ already has an IP address different from 1</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_42562106/article/details/123749291</span><br></pre></td></tr></table></figure><p>3、failed to add vxlanRoute (10.244.0.0/24 -&gt; 10.244.0.0): network is down</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip link delete flannel.1</span><br><span class="line">systemctl restart network</span><br><span class="line">kubectl delete -f kube-flannel.yml</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure><p>4、Get <a href="http://10.244.0.3:8181/ready" target="_blank" rel="noopener">http://10.244.0.3:8181/ready</a>: dial tcp 10.244.0.3:8181: connect: connection refused</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重新coredns</span></span><br><span class="line">kubectl -n kube-system rollout restart deployment/coredns</span><br></pre></td></tr></table></figure><p>以上几个问题遇到可以先尝试重启所有的机器，如果不行在通过上述方案解决</p><blockquote><p>参考：<a href="https://">https://www.iuskye.com/2021/08/10/k8s-kubeadm-1213.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;k8s搭建&quot;&gt;&lt;a href=&quot;#k8s搭建&quot; class=&quot;headerlink&quot; title=&quot;k8s搭建&quot;&gt;&lt;/a&gt;k8s搭建&lt;/h2&gt;&lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说</summary>
      
    
    
    
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="k8s" scheme="http://example.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>redisson3.15.2 公平锁任务丢失</title>
    <link href="http://example.com/2023/03/31/redisson3.15.2%20%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%BB%E5%8A%A1%E4%B8%A2%E5%A4%B1/"/>
    <id>http://example.com/2023/03/31/redisson3.15.2%20%E5%85%AC%E5%B9%B3%E9%94%81%E4%BB%BB%E5%8A%A1%E4%B8%A2%E5%A4%B1/</id>
    <published>2023-03-31T15:22:45.000Z</published>
    <updated>2023-03-31T15:37:33.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>场景：</p><p>线索流转改成 redisson 公平锁，任务耗时长，导致部分任务丢失。</p></blockquote><h4 id="一、redisson-公平锁实现"><a href="#一、redisson-公平锁实现" class="headerlink" title="一、redisson 公平锁实现"></a><strong>一、redisson 公平锁实现</strong></h4><h5 id="1、redis-中的-K-V"><a href="#1、redis-中的-K-V" class="headerlink" title="1、redis 中的 K/V"></a>1、redis 中的 K/V</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">list:</span> <span class="string">redisson_lock_queue:&#123;test&#125;</span>    </span><br><span class="line"><span class="attr">elem:</span> <span class="string">UUID:threadId</span></span><br><span class="line"><span class="attr">zset:</span> <span class="string">redisson_lock_timeout:&#123;key&#125;</span>   </span><br><span class="line"><span class="attr">elem:</span> <span class="string">UUID:threadId</span>  </span><br><span class="line"><span class="attr">score:</span> <span class="string">timeout</span> <span class="string">=</span> <span class="string">ttl</span> <span class="string">+</span> <span class="string">线程等待时间(5*60000ms)</span> <span class="string">+</span> <span class="string">当前时间戳</span></span><br><span class="line"><span class="attr">hset:</span> <span class="string">key</span> </span><br><span class="line">  <span class="attr">hashKey:</span> <span class="string">UUID:threadId</span> </span><br><span class="line">  <span class="attr">hashVal:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2、上锁流程（这里就不放源码了，感兴趣可以自己看看）"><a href="#2、上锁流程（这里就不放源码了，感兴趣可以自己看看）" class="headerlink" title="2、上锁流程（这里就不放源码了，感兴趣可以自己看看）"></a>2、上锁流程（这里就不放源码了，感兴趣可以自己看看）</h5><blockquote><p>org.redisson.RedissonFairLock#tryLockInnerAsync</p></blockquote><ul><li>清除 redisson_lock_timeout:{key} 中 score 小于当前时间戳的elem，同时清除对应 redisson_lock_queue:{test} 中的 elem</li><li>如果当前没有线程占用锁，则上锁 (ttl = watchdogtimeout)，同时redisson_lock_timeout:{key} 中所有的 score - 线程等待时间(5*60000ms)</li><li>如果存在锁，且是被当前线程占用的，则 hashVal 加一</li><li>如果存在锁，且不是被当前线程占用的，同时已经加入过等待队列，则返回当前线程在队列中的 ttl</li><li>如果存在锁，且不是被当前线程占用的，并且未加入等待队列，则加入等待队列，timeout= ttl + 线程等待时间(5*60000ms) + 当前时间戳，ttl 为队列中最后一个元素的 timeout - current 或者 锁的超时时间</li></ul><h5 id="3、订阅-redisson-lock-channel-fairLock-UUID-threadId"><a href="#3、订阅-redisson-lock-channel-fairLock-UUID-threadId" class="headerlink" title="3、订阅 redisson_lock__channel:{fairLock}:UUID:threadId"></a>3、订阅 redisson_lock__channel:{fairLock}:UUID:threadId</h5><p>此处阻塞线程，直到消息队列中有消息发送为止</p><h5 id="4、解锁流程"><a href="#4、解锁流程" class="headerlink" title="4、解锁流程"></a>4、解锁流程</h5><ul><li>清除 redisson_lock_timeout:{key} 中 score 小于当前时间戳的elem，同时清除对应 redisson_lock_queue:{test}   中的 elem</li><li>判断锁是否存在，如果不存在则说明锁已经被释放了，判断等待队列中是否有elem，有的话取出第一个 publish message</li><li>如果锁存在，且非本线程持有，则直接返回 null</li><li>如果所存在，且是当前线程持有，并且获取所次数大于 1，则 hashVal减一，更新锁超时时间</li><li>如果所存在，且是当前线程持有，释放锁，判断等待队列中是否有elem，有的话取出第一个 publish message</li></ul><h5 id="5、获取到锁之后，取消订阅-redisson-lock-channel-fairLock-UUID-threadId"><a href="#5、获取到锁之后，取消订阅-redisson-lock-channel-fairLock-UUID-threadId" class="headerlink" title="5、获取到锁之后，取消订阅 redisson_lock__channel:{fairLock}:UUID:threadId"></a>5、获取到锁之后，取消订阅 redisson_lock__channel:{fairLock}:UUID:threadId</h5><hr><h4 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a><strong>二、问题分析</strong></h4><p>1、由于测试环境第三方鉴权接口较慢，每分配一条线索需要3-4s</p><p>2、存量线索有 1500+ 条，每 200 条作为一个任务，总共拆分 8 个任务，每个任务需要执行 200*3 = 600+ s</p><p>3、redisson 公平锁线程等待时间 (5*60000ms)，也就是说单个任务执行完至少会有一个任务过期，在 unlock 或者 lock 操作是会先清除过期任务</p><p>4、由于获取不到锁，线程会订阅 redisson_lock__channel:{fairLock}:UUID:threadId，阻塞知道接收到消息，又由于等待队列里的线程被清了，这个消息队列永远不会收到消息，所以线程一直阻塞，且任务无法执行，资源被占用。</p><p>5、代码模拟：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">        Redisson redissonClient = (Redisson) Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        IntStream.range(<span class="number">0</span>, <span class="number">10</span>).forEach(i -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//RedissonFairLock lock = (RedissonFairLock) redissonClient.getFairLock("test");</span></span><br><span class="line">                RedissonFairLock lock = <span class="keyword">new</span> RedissonFairLock(redissonClient.getCommandExecutor(), <span class="string">"test"</span>, <span class="number">2000</span>);</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="comment">//最终输出次数小于10</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                ThreadUtil.sleep(<span class="number">10000</span>);</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/maybesuch/p/16012674.html" target="_blank" rel="noopener">参考: Redisson分布式锁之公平锁原理</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;场景：&lt;/p&gt;
&lt;p&gt;线索流转改成 redisson 公平锁，任务耗时长，导致部分任务丢失。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;一、redisson-公平锁实现&quot;&gt;&lt;a href=&quot;#一、redisson-公平锁实现&quot; class</summary>
      
    
    
    
    <category term="redisson" scheme="http://example.com/categories/redisson/"/>
    
    
    <category term="redisson" scheme="http://example.com/tags/redisson/"/>
    
    <category term="框架" scheme="http://example.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>apollo 集群架构</title>
    <link href="http://example.com/2023/03/26/apollo-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2023/03/26/apollo-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/</id>
    <published>2023-03-25T18:25:23.000Z</published>
    <updated>2023-03-31T15:44:48.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apollo-集群架构"><a href="#apollo-集群架构" class="headerlink" title="apollo 集群架构"></a>apollo 集群架构</h1><h3 id="apollo-组成结构"><a href="#apollo-组成结构" class="headerlink" title="apollo 组成结构"></a>apollo 组成结构</h3><p>apollo 集群主要有三个部分组成，config-service，admin-service，portal</p><ul><li>config-service: 主要为应用客户端提供服务，包括配置的读取、推送等功能，config-service 内置 eureka，已提供 admin-service, portal 的服务发现、服务注册</li><li>admin-service: 主要为 apollo-portal 提供服务，包括应用配置管理、发布等功能</li><li>portal: 是 apollo 提供的服务配置前端页面</li></ul><h3 id="apollo-部署方案"><a href="#apollo-部署方案" class="headerlink" title="apollo 部署方案"></a>apollo 部署方案</h3><p><img src="/images/283b123b3a2d818fb3f732c9a1b75a5d.png" alt="截图" style="zoom:100%" />这个官网提供的高可用双环境架构，更多的架构方案可<a href="https://www.apolloconfig.com/#/zh/deployment/deployment-architecture?id=_34-%e9%ab%98%e5%8f%af%e7%94%a8%ef%bc%8c%e5%a4%9a%e4%b8%aa%e7%8e%af%e5%a2%83" target="_blank" rel="noopener">参考</a></p><h3 id="docker-compose-部署-apollo-集群"><a href="#docker-compose-部署-apollo-集群" class="headerlink" title="docker-compose 部署 apollo 集群"></a>docker-compose 部署 apollo 集群</h3><ol><li>执行 <a href="https://github.com/apolloconfig/apollo-quick-start/tree/master/sql" target="_blank" rel="noopener">sql 脚本</a>，生成 apollo 需要的 db 表</li><li>编写 docker-compose 文件，本次只搭建开发环境模拟单机单环境，config-service，admin-service，portal 都各自部署一个容器</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">net:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment">#开发环境configService，eureka</span></span><br><span class="line">  <span class="attr">apollo-configservice-dev:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apolloconfig/apollo-configservice</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">configservice-dev</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://192.168.0.103:3306/ApolloConfigDB?characterEncoding=utf8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eureka.instance.ip-address=192.168.0.103</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">apollo-adminservice-dev:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apolloconfig/apollo-adminservice</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">adminservice-dev</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8090</span><span class="string">:8090</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://192.168.0.103:3306/ApolloConfigDB?characterEncoding=utf8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=123456</span></span><br><span class="line">      <span class="comment">#这里需要配置开环环境的configService</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">eureka.service.url=http://configservice-dev:8080/eureka/</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apollo-configservice-dev</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">apollo-portal:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">apolloconfig/apollo-portal</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">apollo-portal</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8070</span><span class="string">:8070</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_URL=jdbc:mysql://192.168.0.103:3306/ApolloPortalDB?characterEncoding=utf8</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_USERNAME=root</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SPRING_DATASOURCE_PASSWORD=123456</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">spring.profiles.active=auth</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APOLLO_PORTAL_ENVS=dev,fat,pre,gray,pro</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DEV_META=http://configservice-dev:8080</span></span><br><span class="line">      <span class="comment"># 以下这些暂时使用开发环境的</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FAT_META=http://configservice-dev:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PRE_META=http://configservice-dev:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">GRAY_META=http://configservice-dev:8080</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PRO_META=http://configservice-dev:8080</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">apollo-adminservice-dev</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">net</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apollo-集群架构&quot;&gt;&lt;a href=&quot;#apollo-集群架构&quot; class=&quot;headerlink&quot; title=&quot;apollo 集群架构&quot;&gt;&lt;/a&gt;apollo 集群架构&lt;/h1&gt;&lt;h3 id=&quot;apollo-组成结构&quot;&gt;&lt;a href=&quot;#apollo</summary>
      
    
    
    
    
    <category term="apollo" scheme="http://example.com/tags/apollo/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>consul 集群搭建及注意事项</title>
    <link href="http://example.com/2023/03/26/consul-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://example.com/2023/03/26/consul-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-03-25T17:16:50.000Z</published>
    <updated>2023-03-31T15:45:02.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p><em>本次利用 docker 搭建 consul 集群，利用 docker-compose 统一管理</em></p><p><em>集群包含三个 server agent: node1、node2、node3</em></p><p><em>集群包含两个 client agent: node4、node5，client agent 提供 ui</em></p><p>**1、下载 docker 镜像 **</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull docker</span><br></pre></td></tr></table></figure><p><strong>2、编辑 docker-compose.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'2'</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">byfn:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">consul1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node1</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">agent</span> <span class="string">-server</span> <span class="string">-bootstrap-expect=3</span> <span class="string">-node=node1</span> <span class="string">-bind=0.0.0.0</span> <span class="string">-client=0.0.0.0</span> <span class="string">-datacenter=dc1</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">consul2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node2</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">agent</span> <span class="string">-server</span> <span class="string">-retry-join=node1</span> <span class="string">-node=node2</span> <span class="string">-bind=0.0.0.0</span> <span class="string">-client=0.0.0.0</span> <span class="string">-datacenter=dc1</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">consul1</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">consul3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node3</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">agent</span> <span class="string">-server</span> <span class="string">-retry-join=node1</span> <span class="string">-node=node3</span> <span class="string">-bind=0.0.0.0</span> <span class="string">-client=0.0.0.0</span> <span class="string">-datacenter=dc1</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">consul1</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">consul4:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node4</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">agent</span> <span class="string">-retry-join=node1</span> <span class="string">-node=ndoe4</span> <span class="string">-bind=0.0.0.0</span> <span class="string">-client=0.0.0.0</span> <span class="string">-datacenter=dc1</span> <span class="string">-ui</span> </span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8500</span><span class="string">:8500</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">consul2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">consul3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">consul5:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">consul</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">node5</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">agent</span> <span class="string">-retry-join=node1</span> <span class="string">-node=ndoe5</span> <span class="string">-bind=0.0.0.0</span> <span class="string">-client=0.0.0.0</span> <span class="string">-datacenter=dc1</span> <span class="string">-ui</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8501</span><span class="string">:8500</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">consul2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">consul3</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">byfn</span></span><br></pre></td></tr></table></figure><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>-server：表示当前使用的 server 模式；如果没有指定，则表示是 client 模式。</p><p>-node：指定当前节点在集群中的名称。</p><p>-config-dir：指定配置文件路径，定义服务的；路径下面的所有 .json 结尾的文件都被访问；缺省值为：/consul/config。</p><p>-data-dir： consul 存储数据的目录；缺省值为：/consul/data。</p><p>-datacenter：数据中心名称，缺省值为 dc1。</p><p>-ui：使用 consul 自带的 web UI 界面 。</p><p>-join：加入到已有的集群中。</p><p>-retry-join：与 -join 类似，但允许重试连接，直到连接成功。一旦成功加入成员列表中的成员，它将永远不会尝试再次加入。然后，代理商将仅通过八卦维持其会员资格。允许配置多个 -retry-join，然后节点会按照顺序加入和重试，直到第一个成功。</p><p>-enable-script-checks： 检查服务是否处于活动状态，类似开启心跳。</p><p>-advertise：通告地址用于更改我们向集群中其他节点通告的地址。相当于 -bind 不可用时更改 -bind 地址，可以理解为 -bind 的一个备选方案。</p><p>-bind： 绑定服务器的 ip 地址，缺省值：“0.0.0.0”，这意味着 consul 将绑定到本地机器上的所有地址，并将私有 IPv4 地址通告给集群的其余节点，如果有多个私有 IPv4 地址可用，consul 将在启动时退出并报错。consul 1.1.0 之后，可以结合 go-sockaddr template使用，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ consul agent -bind &#39;&#123;&#123; GetPrivateInterfaces | include &quot;network&quot; &quot;10.0.0.0&#x2F;8&quot; | attr &quot;address&quot; &#125;&#125;&#39;</span><br></pre></td></tr></table></figure><p>-client：客户端可访问 ip，缺省值为：“127.0.0.1”，即仅允许环回连接。</p><p>-bootstrap-expect：在一个 datacenter 中期望的 server 节点数目，consul 启动时会一直等待直到达到这个数目的server才会引导整个集群。这个参数的值在同一个 datacenter 的所有server节点上必须保持一致。</p><p>-bootstrap：用来控制一个 server 是否运行在 bootstrap 模式：当一个 server 处于 bootstrap 模式时，它可以选举自己为 leader；注意在一个 datacenter 中只能有一个 server 处于 bootstrap 模式。所以这个参数一般只能用在只有一个 server 的开发环境中，在有多个 server 的 cluster 产品环境中，不能使用这个参数，否则如果多个 server 都标记自己为 leader 那么会导致数据不一致。另外该标记不能和 -bootstrap-expect 同时指定。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p><strong>1、通过 config-file 注册服务</strong>，编辑 xxx.json，然后放在 /consul/config 目录下（默认情况）,当然也可以通过 <a href="https://www.consul.io/commands/config/write" target="_blank" rel="noopener">consul 命令行</a>加载配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                                                                                                                                   </span><br><span class="line">  <span class="attr">"services"</span>: [                                                                                                                                     </span><br><span class="line">    &#123;                                                                                                                                               </span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"hertz-demo-001"</span>,                                                                                                                       </span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"hertz-demo"</span>,                                                                                                                         </span><br><span class="line">      <span class="attr">"tags"</span>: [                                                                                                                                     </span><br><span class="line">      ],                                                                                                                                            </span><br><span class="line">      <span class="attr">"address"</span>: <span class="string">"192.168.0.103"</span>,                                                                                                                       </span><br><span class="line">      <span class="attr">"port"</span>: <span class="number">5000</span>,                                                                                                                                 </span><br><span class="line">      <span class="attr">"checks"</span>: [                                                                                                                                   </span><br><span class="line">        &#123;                                                                                                                                           </span><br><span class="line">        <span class="attr">"http"</span>: <span class="string">"http://192.168.0.103:5000/ping"</span>,                                                                                                       </span><br><span class="line">        <span class="attr">"tlsSkipVerify"</span>: <span class="literal">false</span>,                                                                                                                   </span><br><span class="line">        <span class="attr">"method"</span>: <span class="string">"GET"</span>,                                                                                                                            </span><br><span class="line">        <span class="attr">"interval"</span>: <span class="string">"10s"</span>,                                                                                                                          </span><br><span class="line">        <span class="attr">"timeout"</span>: <span class="string">"1s"</span>,                                                                                                                             </span><br><span class="line">        <span class="attr">"deregisterCriticalServiceAfter"</span>: <span class="string">"30s"</span></span><br><span class="line">        &#125;                                                                                                                                           </span><br><span class="line">      ]                                                                                                                                             </span><br><span class="line">    &#125;                                                                                                                                               </span><br><span class="line">  ]                                                                                                                                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、执行 consul 命令重载配置文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul reload</span><br></pre></td></tr></table></figure><p><strong>3、启动 web 服务</strong>，这里使用自己熟悉的语言写一个简单的服务即可，这里用的是 go http 框架 hertz:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"github.com/cloudwego/hertz/pkg/app"</span></span><br><span class="line"><span class="string">"github.com/cloudwego/hertz/pkg/app/server"</span></span><br><span class="line"><span class="string">"github.com/cloudwego/hertz/pkg/common/utils"</span></span><br><span class="line"><span class="string">"github.com/cloudwego/hertz/pkg/protocol/consts"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := server.Default(</span><br><span class="line">server.WithHostPorts(<span class="string">"192.168.0.103:5000"</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">s.GET(<span class="string">"/ping"</span>, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req *app.RequestContext)</span></span> &#123;</span><br><span class="line">log.Print(req.ClientIP(), <span class="string">" ping"</span>)</span><br><span class="line">req.JSON(consts.StatusOK, utils.H&#123;<span class="string">"ping"</span>: <span class="string">"pong"</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">s.Spin()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4、查看服务健康信息</strong>，passing 参数表示是否过滤不健康的服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://127.0.0.1:8500/v1/health/service/hertz-demo\?passing\=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>5、注销服务</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --request PUT 127.0.0.1:8501/v1/agent/service/deregister/hertz-demo-001</span><br></pre></td></tr></table></figure><p><strong>6、consul ui 界面上显示如下：</strong></p><img src="/images/15a776f6a2dd3e8cd4405101c5e47f9c.png" alt="截图" style="zoom:0%" /><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、注册服务时，check 参数 method GET 注意 GET 需要大写，否则健康检查会失败</p><p>2、服务注册的 client agent 挂了，那么 consul 会认为服务也挂了，并不会做故障转移，也不会同步原本 client agent 下的服务信息</p><p>3、服务注册需要确保网络能联通</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p><strong>1、官方推荐的架构方式</strong></p><p>官方建议一个集群部署 3-5 个 server agent，每个服务的服务器部署一个 client agent，如下如所示：</p><img src="/images/d54b9c5750f98deb333af08e95cd8c74.png" alt="截图" style="zoom:100%;" /><p><strong>2、如是想要统一管理 consul agent</strong>，那可以参考另一种架构方式：</p><img src="/images/46d62fa92deb1760cdec0d06f983dd1d.png" alt="截图" style="zoom:100%" /><br/><br/><blockquote><p>参考：<br><a href="https://mp.weixin.qq.com/s/ecmqqWuMho2a0xhaF1vFNA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ecmqqWuMho2a0xhaF1vFNA</a><br><a href="https://www.cnblogs.com/brady-wang/p/14440649.html/" target="_blank" rel="noopener">https://www.cnblogs.com/brady-wang/p/14440649.html</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;集群搭建&quot;&gt;&lt;a href=&quot;#集群搭建&quot; class=&quot;headerlink&quot; title=&quot;集群搭建&quot;&gt;&lt;/a&gt;集群搭建&lt;/h3&gt;&lt;p&gt;&lt;em&gt;本次利用 docker 搭建 consul 集群，利用 docker-compose 统一管理&lt;/em&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    
    <category term="consul" scheme="http://example.com/tags/consul/"/>
    
    <category term="运维" scheme="http://example.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/03/26/hello-world/"/>
    <id>http://example.com/2023/03/26/hello-world/</id>
    <published>2023-03-25T16:04:15.447Z</published>
    <updated>2023-03-25T16:04:15.447Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
